{"posts":[{"title":"新手表居然就卡bug？watchOS 9 太拉了...","text":"此问题已在 watchOS 9.0.2 中修复。 如图 高高兴兴地开箱 你还可以：在B站观看 麦克风开始抽风刚刚激活，就… 又陆陆续续失灵了几次，重启都能解决… 发了条微博：麦克风失灵 评论来看，也有问题… 在论坛里也找到了一样的问题：iwatch s8 麦克风高频率拾音故障 吐槽下，iWatch是什么东西…懂，但是没有这个名字 复现问题 &amp;&amp; 反馈问题觉得像是软件的 bug 打了个 400 电话，让我重新配对， 肯定是没效果的啦！ 但是， 我感觉像是噪声app的环境音量检测出 bug 了，关掉之后，确实缓解了。 解决了，但是没有完全解决。 好在， 又发现了一个不用重启的解决方案， 放充电器上充会儿电就好了。 解决方案目前为止有三种解决方案，再来梳理一下： 重启 Apple Watch（只能短暂解决，后续还可能会出现相同的问题，需要再次重启） 关闭噪声app中的环境音量测量（在watch设置-噪声中） 出现该问题时，将手表放到充电器上充电5分钟，可以恢复 其中，第一种只能短暂地解决该问题，第二种能缓解该问题，第三种也只能作为一种补救措施。 我的建议是：第二第三种搭配使用。 苹果那边已经反馈过去了，正在等待 watchOS 9.0.1或者 watchOS 9.1解决这个问题。 奇怪的是， 用第二种关闭了环境音量检测后，仍然可以在健康app里查看到环境噪声分贝的信息， 而且数据还是手表提供的 真垃圾！ 后续貌似苹果确认了 确认了这个问题的存在， 但是不知道能不能找到问题的原因， 这决定了最终能不能修复这个bug。 2022.10.11 watchOS 9.0.2 更新日志中写道：修复了部分 Apple Watch Series 8 和 Ultra 用户的麦克风音频中断的问题 经过测试，重新打开“环境音量检测”后一整天都没再出现此问题了","link":"/apple-watch-series-8-mic-failed/"},{"title":"ASCII码对应关系","text":"版权声明 图片来源于百度百科 Tips 大小写转换 ±32 A-Z &lt; a-z 字母范围：65-90，97-122 数字范围：48-57 “A”为65；“a”为97；“0”为 48 ASCII 可输出 %d（字符的 ASCII 码的十进制数），也可输出 %c（对应的字符）。","link":"/ascii/"},{"title":"Google Chromium Encryption Structure","text":"来源：GitHub，仅供学习使用。 Google Chrome stores browser cookies in an SQLite database. The database has two tables, meta containing format and version metadata, and cookies with the contents of the cookies. The cookies table uses this schema: 1234567891011121314151617181920-- To reproduce: sqlite path/to/Cookies .schemaCREATE TABLE cookies ( creation_utc INTEGER NOT NULL, -- microseconds since epoch host_key TEXT NOT NULL, -- domain name TEXT NOT NULL, value TEXT NOT NULL, path TEXT NOT NULL, expires_utc INTEGER NOT NULL, -- microseconds since epoch is_secure INTEGER NOT NULL, is_httponly INTEGER NOT NULL, last_access_utc INTEGER NOT NULL, has_expires INTEGER NOT NULL DEFAULT 1, is_persistent INTEGER NOT NULL DEFAULT 1, priority INTEGER NOT NULL DEFAULT 1, encrypted_value BLOB DEFAULT '', samesite INTEGER NOT NULL DEFAULT -1, source_scheme INTEGER NOT NULL DEFAULT 0, UNIQUE (host_key, name, path)); TimestampsThe expires_utc and creation_utc fields contain timestamps given as integer numbers of microseconds elapsed since midnight 01-Jan-1601 UTC in the proleptic calendar. The Unix epoch is 11644473600 seconds after this moment. ValuesThe value and encrypted_value fields are used to store cookie values. In practice, one or the other is populated, but not both. value encrypted_value Description empty non-empty Value is encrypted non-empty empty Value is unencrypted empty empty Value is unencrypted non-empty non-empty (not observed) Storage FormatAn encrypted value consists of a data packet that is encrypted with AES-128 in CBC mode. The encrypted data packet has the following format: Bytes Content Description 3 “v10” (0x76 0x31 0x30) Version tag (unencrypted) n value Payload (encrypted) p padding Padding (encrypted), 1–16 bytes The encrypted portion of the packet (n+ p) contains a multiple of 16 bytes. If n is a multiple of 16, p = 16; otherwise 1 ≤ p ≤ 15. PaddingBefore encryption, p bytes of padding are added to the plaintext value to ensure a multiple of 16 bytes. At least one byte of padding is always added, so if the value is already a multiple of 16 bytes, p=16 additional are added. Each padding byte has the value p, so if p=5, the padding is the 5-byte sequence [5, 5, 5, 5, 5]. After decryption, the padding must be removed, and it can be used to verify that the decryption key was correct. The final byte of the decrypted packet must be a padding byte with value 1 ≤ p ≤ 16, and the last p bytes of the packet must contain the value p. Otherwise, the decryption key can be assumed to be incorrect. EncryptionEncryption and decryption are performed using AES-128 in cipher-block chaining (CBC) mode with an initialization vector consisting of 16 space bytes (Unicode 32). The encryption key is described below. Key GenerationThe 16-byte AES-128 encryption key is generated using the PBKDF2 (RFC 2898) algorithm from a user-provided passphrase. The key generation salt is the fixed string saltysalt. On macOS, Chrome uses 1003 iterations of the key generation algorithm; on Linux it uses 1 iteration. I don’t know what it does on Windows.","link":"/chromium-encryption-structure/"},{"title":"C语言 之 格式化输出","text":"前两天上课的时候，老师让输出个九九乘法表。 但是实际输出会觉得怪怪的，没对齐，尝试下对齐吧。 这样也不是不行是吧，哈哈。 123456789printf(&quot;1x1=1&quot;);printf(&quot;2x1=2 2x2= 4&quot;);printf(&quot;3x1=3 3x2= 6 3x3= 9&quot;);printf(&quot;4x1=4 4x2= 8 4x3=12 4x4=16&quot;);printf(&quot;5x1=5 5x2=10 5x3=15 5x4=20 5x5=25&quot;);printf(&quot;6x1=6 6x2=12 6x3=18 6x4=24 6x5=30 6x6=36&quot;);printf(&quot;7x1=7 7x2=14 7x3=21 7x4=28 7x5=35 7x6=42 7x7=49&quot;);printf(&quot;8x1=8 8x2=16 8x3=24 8x4=32 8x5=40 8x6=48 8x7=56 8x8=64&quot;);printf(&quot;9x1=9 9x2=18 9x3=27 9x4=36 9x5=45 9x6=54 9x7=63 9x8=72 9x9=81&quot;); 没对齐的版本123456789101112#include &lt;stdio.h&gt;int main(){ int i,j; for(i = 1; i &lt;= 9; i++) { for(j = 1; j &lt;= i; j++) { printf(&quot;%dx%d=%d &quot;, i, j, i*j); } printf(&quot;\\n&quot;); } return 0;} 对占位符格式化输出就用乘法表作为例子， 输出的是 Int（%d）， 需要对一位数的结果进行扩展，让它能够对齐下面的两位数数字。 格式化输出格式：% (-/0) [位宽 n] . [精度 m] d 格式中我增加了空格，方便阅读，实际代码中不能有空格哦。 解释一下： 位宽 n：输出的内容占命令行的 n 个字符宽度，比如：[4]（n=1），[ 4]（n=2） 精度m：小数点后保留几位（貌似默认是 6 好像），比如 printf(&quot;%.2f&quot;, 3.1415); 输出的是3.14 -/0：这一部分是对自定义格式的一个补充。 ‘-‘：靠左输出（方括号并非输出内容，只是方便看到空格哈） printf(&quot;%-2d, 1&quot;); 输出的是：[1 ] printf(&quot;%2d, 1&quot;); 输出的是：[ 1] ‘0’：左侧补0⃣️ printf(&quot;%02d, 1&quot;); 输出的是：01 -/0 只能用一个，其中（靠左输出’-‘）的优先级更高，所以 printf(&quot;%-02d&quot;, 1); 输出的是 [1 ] %d 就没有必要设置精度了哈，三个格式化可以独立使用，但是要设置精度的话记得加上 Dot（.） 哦！ 比如： %-2d %05d %.3f %-5.2f … 可以在电脑上试试看这些的输出，更好地理解下。 改进后的版本 靠右对齐： 123456789101112#include &lt;stdio.h&gt;int main(){ int i,j; for(i = 1; i &lt;= 9; i++) { for(j = 1; j &lt;= i; j++) { printf(&quot;%dx%d=%2d &quot;, i, j, i*j); } printf(&quot;\\n&quot;); } return 0;} 输出结果 1x1= 12x1= 2 2x2= 43x1= 3 3x2= 6 3x3= 94x1= 4 4x2= 8 4x3=12 4x4=165x1= 5 5x2=10 5x3=15 5x4=20 5x5=256x1= 6 6x2=12 6x3=18 6x4=24 6x5=30 6x6=367x1= 7 7x2=14 7x3=21 7x4=28 7x5=35 7x6=42 7x7=498x1= 8 8x2=16 8x3=24 8x4=32 8x5=40 8x6=48 8x7=56 8x8=649x1= 9 9x2=18 9x3=27 9x4=36 9x5=45 9x6=54 9x7=63 9x8=72 9x9=81 补零版本： 123456789101112#include &lt;stdio.h&gt;int main(){ int i,j; for(i = 1; i &lt;= 9; i++) { for(j = 1; j &lt;= i; j++) { printf(&quot;%dx%d=%02d &quot;, i, j, i*j); } printf(&quot;\\n&quot;); } return 0;} 输出结果 1x1=012x1=02 2x2=043x1=03 3x2=06 3x3=094x1=04 4x2=08 4x3=12 4x4=165x1=05 5x2=10 5x3=15 5x4=20 5x5=256x1=06 6x2=12 6x3=18 6x4=24 6x5=30 6x6=367x1=07 7x2=14 7x3=21 7x4=28 7x5=35 7x6=42 7x7=498x1=08 8x2=16 8x3=24 8x4=32 8x5=40 8x6=48 8x7=56 8x8=649x1=09 9x2=18 9x3=27 9x4=36 9x5=45 9x6=54 9x7=63 9x8=72 9x9=81 靠左对齐： 123456789101112#include &lt;stdio.h&gt;int main(){ int i,j; for(i = 1; i &lt;= 9; i++) { for(j = 1; j &lt;= i; j++) { printf(&quot;%dx%d=%-2d &quot;, i, j, i*j); } printf(&quot;\\n&quot;); } return 0;} 输出结果 1x1=12x1=2 2x2=43x1=3 3x2=6 3x3=94x1=4 4x2=8 4x3=12 4x4=165x1=5 5x2=10 5x3=15 5x4=20 5x5=256x1=6 6x2=12 6x3=18 6x4=24 6x5=30 6x6=367x1=7 7x2=14 7x3=21 7x4=28 7x5=35 7x6=42 7x7=498x1=8 8x2=16 8x3=24 8x4=32 8x5=40 8x6=48 8x7=56 8x8=649x1=9 9x2=18 9x3=27 9x4=36 9x5=45 9x6=54 9x7=63 9x8=72 9x9=81","link":"/formatted-output-in-c-programming-language/"},{"title":"理解函数中的泛型 &amp; 泛型约束 —— 究竟谁才是入口？","text":"继续接上篇，做完 AnyMyCollection 之后， 我又添加了一个扩展来修改 CustomCollection 在特定类型下的行为： 12345extension CustomCollection where Element == Int { func allValues() -&gt; [Element] { [4, 5, 6] }} 当 Element 是 Int 时，不管三七二十一，直接返回 [4, 5, 6] 但是，运行是发现了这样的现象： 12345let collection = CustomCollection(1, 2, 3)print(collection.allValues()) // [4, 5, 6]let any = AnyMyCollection(collection)print(any.allValues()) // [1, 2, 3] 同一个东西，擦除类型之后就不受 Element == Int 约束了嘛？不是 写了一个最小可复现问题的代码，如下： 1234567let collection = CustomCollection(1, 2, 3)func genericFuntion&lt;C: MyCollection&gt;(_ base: C) { print(base.allValues()) // [1, 2, 3]}genericFuntion(collection) 重新来看这个函数， base 是一个符合 MyCollection 协议的类型， 从程序的角度看，调用函数的时候，它会去找一个入口， 在这里，入口就应该是让 CustomCollection 符合协议的那个 allValues()， 而 Element == Int 约束则可以理解为，当符合条件时，对 allValues() 进行重写， 这里真正让 CustomCollection 符合 MyCollection 的是不受约束的那个扩展中的方法。 仔细一想，貌似实际操作中貌似不会这样“重写”函数， 而是会对一些特定的类型增加一个特殊的函数， 比如：对于类型是 Int 的 Array 增加求平均值的函数等等。","link":"/generic-type-function-entry-point/"},{"title":"搞笑体育 之 跑步是不可能跑步的","text":"众所周知，高校体育就是一坨… 且不说功能如何， 你一个给大学生用的“运动”软件， 开屏一大堆广告，手机动一下就乱跳app， 跑个步还不忘给我打广告，从头打到尾，真牛… 傻*软件，吃像太难看！ 跑个步还要打卡点位，真的恶心，但是，跑步是肯定不会跑的啦～ 流程分析对 APP 的网络请求进行一番抓包，整个流程比较简单： 手机点击开始体育锻炼跑，APP 发送一个请求 服务器返回当前跑步的 RunPageID 和需要经过的点位信息 开跑，记得要满足跑步要求（2公里 + 3个点） 完成跑步之后，将途径的一个个采样点进行处理，一并发给服务器，完成跑步记录上报保存。 一些细节 所有请求均以 POST 方式发送 所有请求的 body 中的均含有 sign 用于校验，使用的是 MD5 生成哈希值 数据结构在每一个请求的 body 中的数据结构长这样：data=[JSON Data]&amp;sign=[MD5 Hash] 开始跑步URL： https://www.sportcampus.cn/api/run/runPage 12345[ &quot;initLocation&quot; : &quot;121.00000,30.00000”, // 起始位置的经纬度 &quot;type&quot; : &quot;1&quot;, // 不知道什么含义 &quot;userid&quot; : &quot;1234567&quot; // 当前用户的 ID] 服务器返回的 JSON 中，ibeacon 和 gpsinfo分别对应 必经点🔴 和 途径点🟢 ibeacon 中关键信息是 major、minor和uuid，后续保存跑步记录是会用到。 gpsinfo 就是简单的字典，包含 latitude 和 longitude。 结束跑步URL：https://www.sportcampus.cn/api/run/saveRunV2 123456789101112131415161718[ &quot;endTime&quot; : &quot;2023-3-13 14:50:39&quot;, &quot;startTime&quot; : &quot;2023-3-13 14:38:15&quot;, &quot;userid&quot; : &quot;1234567&quot;, &quot;goal&quot; : &quot;2.00&quot;, &quot;type&quot; : 1, &quot;frombp&quot; : 0, &quot;runPageId&quot; : pageID, &quot;buPin&quot; : &quot;100&quot;, &quot;speed&quot; : &quot;6'13\\&quot;&quot;, &quot;real&quot; : &quot;300&quot;, // 距离，单位（米） &quot;duration&quot; : &quot;658&quot;, // 时常，单位（秒） &quot;track&quot; : [], // 跑步过程中 GPS 采样点 &quot;bNode&quot; : bNode, // 必经点数据🔴 &quot;tNode&quot; : tNode, // 途径点数据🟢 &quot;totalNum&quot; : &quot;1024&quot;, // 步数 &quot;trend&quot; : [[&quot;x&quot; : &quot;0&quot;, &quot;y&quot; : &quot;0&quot;]]] 这里只要给速度生成一个随机数，其他基本都能算出来。 途径点、必经点打卡实际上就是 bNode 和 tNode，把“想经过的”点给进去就好啦。 bNode 是一个字典数组，字典的结构如下： 12345[ &quot;major&quot; : String, &quot;minor&quot; : String, &quot;uuid&quot; : UUID] tNode 相对简单，也是一个字典数组，结构如下： 1234[ &quot;longitude&quot; : String, &quot;latitude&quot; : String] track 是间隔一段时间的 GPS 采样点，也是字典数组，结构如下： 12345[ &quot;speed&quot; : String, // 应该是记录采样时的速度，具体单位不清楚，一般跑步在 2.0 - 3.0 左右 &quot;longitude&quot; : String, &quot;latitude&quot; : String] Sign 的获取在 GitHub 上找到了 Python 的版本，直接拿到了 key， 借助 ChatBot 得到了 Swift 版本的 MD5 哈希生成函数， 把 data 构建好之后，转为 String 传进去就好啦。 1234567891011import CryptoKitimport Foundationfunc getMD5Code(_ s: String) -&gt; String { let key = &quot;lpKK*TJE8WaIg%93O0pfn0#xS0i3xE$z&quot; let message = key + &quot;data&quot; + s let data = Data(message.utf8) var hasher = Insecure.MD5() hasher.update(data: data) return hasher.finalize().map { String(format: &quot;%02hhx&quot;, $0) }.joined()} 如何规划路径答：得到必经点和途径点后，手动规划。 用 SwiftUI + MapKit 做了一个 UI，在地图上标注出关键点， 接下来就是鼠标点点点！ 相邻的两个点中间会补齐来实现 “GPS 间隔采样”， 当然，跑步一定不会是笔笔直的，也适当的对每一个中间点做了横纵向的随机偏移。 仍需注意的是：在过河以及转弯时要小心一些😂 跑步流程 点击跑步按钮 规划路线 点击结束跑步 等待提交… 舒服！耶！跑步是不可能跑步的啦～ 项目不开源，涉及多方利益与合作，仅在我自己电脑上运行使用。","link":"/hack-college-sport/"},{"title":"就爱在网上BB？IP直接拿捏你","text":"发生在高中同学身上的真实事件。 这年头还有人喜欢在互联网上平白无故地造谣的嘛？ 还是一个高中的， 表面看看还真不觉得… 实际上做着下三滥的事情。 一会儿立信一会儿🐔大。 害。 一些经过言归正传。 先简单捋一下经过哈。 在用小号跟她“了解”情况过后，也要到了QQ，应该是小号，确定了两名“嫌疑人”， 分别在衫达（嘉善校区）和上海建桥学院， 但是也没有找到别的证据能很好的判断是谁。 好就好在一个开学了一个没开，两所学校的大致距离（一公里的那个圈）相差蛮远的。 脑中浮现出一个想法，IP能定位吗？ 答案是，可以，而且还蛮准。 所需准备 一个合理的理由（要点开才能获取到IP然后上传，对吧？） 后端结构化数据存储服务器（用来存接收到的IP） 一个域名（用来配置服务器，免费的就行） 一些JS的基础（要写一个网页的嘛～） 后端存储服务器之前做博客的时候用过Leancloud做评论系统， 后续这个新博客的评论系统也将基于 Leancloud。 这次用的是Leancloud国际版。 至于为什么是国际版后面会说。 IP获取用的是搜狐开放的script嵌入。 1&lt;script src=&quot;https://pv.sohu.com/cityjson?ie=utf-8&quot;&gt;&lt;/script&gt; 1var ip_address = returnCitySN[&quot;cip&quot;] 数据上传这部分在 Leancloud 的技术文档里写的很明白， 我这个需求其实就是把获取到的IP地址字符串上传到 Leancloud 结构化存储中， 稍微改下实例代码就行。 具体不多赘述，想要了解的可以看技术文档。 至于为什么要用国际版 因为国内版本强制要求添加 API 域名并且需要备案 时间紧迫 也不想搞这些东西 申请一个免费的简单用下就好国际版不需要提供 serverURL 但是国内网络上传会 403，所以申请了个域名，配置好以后国内外都能用，也不需要备案了 免费域名在 Freenom。 一切就绪 坐等IP网页发过去，被对面点开， 过了会儿显示连接错误， 你以为是真的连接错误吗？格局小了 我代码里写的就是错误🤣， 我这里显示他点开了4次。 IP、设备类型 也完美接收过来了。 让我看看你在哪拿到IP就是要找位置咯？ 在这查询下IP的大致位置 大致精度在1公里左右， 那么 是谁也就一目了然了。 写在最后这属于是多年来的技术经验的一次大考，之前做个人博客的时候有幸接触到了这些，这次才比较顺利。 最好的结果就是能找到这个在网络上伪装他人发布谣言的傻zi（B） 真的，给他测试的时候真的很开心，做出来了，精度可以，努力不白费。 也希望这个伪装别人造谣的人在私立大学里好好反省吧，看接下来学校怎么对她处理了，哈哈 顺便记录下时间点： 9.27 第一次发现在贴吧造谣 9.28 被我查到 IP 定位，依然很拽，晚上还在贴吧BB（也是这一天受害者向他们学校发送了邮件举报） 9.29 早上10点左右开始关闭贴吧私信，QQ删除好友并设置不可搜索，微信号更改并设置不可搜索 9.30 贴吧更新头像：差不多得了。 哈哈，画上圆满的句号。","link":"/ip-locate/"},{"title":"JsDelivr不灵了？淦！","text":"还记得几年前做博客的时候， 图片上传到 GitHub 上， 用 JsDelivr 拉取 GitHub 上的静态资源， 速度嘎嘎快， 但是最近发现， 静态资源貌似都被重定向到 githubusercontent 上去了， 可是，官网上却写着： DNS 被污染GitHub 上的 issue： Jsdelivr has been block again in China. Some places are polluted by DNS and are resolved to the IP of websites such as Facebook, Twitter, etc. Although other places can be resolved to the correct IP, they are reset by GWF during the TLS handshake and still inaccessible.But fortunately, fastly.jsdelivr.net is not polluted at present. 至于原因， 估计是某些人把非法的东西挂到 GitHub 上面去分享， 用 JsDelivr 去正常访问， 钻空子别发现了 哈哈。 不过好在 DNS 污染已经被解决，但是在大陆地区也增加了许多限制了，来保证不会再次被污染。 有什么影响？DNS解析现在已经恢复正常， 但是国内的 ICP 应该是不可能恢复了， JsDelivr 也不再提供 中国大陆地区 的 GitHub 静态资源的加速，（JS CSS 类文件除外） 所以博客内的图片也只能从 GitHub 拉取了， 导致网站加载时间可能会略长。 6月份的时候国内静态资源已经不给访问了 中国仅此一家合法的公共 CDN 就这么被限制了。 ICP也被吊销了。 淦！！ 怎么办呢？ 我也在寻找更优的解决方案来加速页面加载。 后续可能考虑从 GitHub 转到国内的 Gitee","link":"/jsdelivr-can-no-longer-accelerate-static-resources/"},{"title":"记录一次  官方召回计划的维修","text":"还记得几年前苹果推出一项召回计划， 所有使用了蝶式键盘的 MacBook 出现键盘问题都可以免费换键盘， 当时买电脑的时候买了 Apple Care+ 本想换块新电池，结果死活卡在 80% - 82%， 当时店员就跟我说让我留意键盘问题，保修时间是4年 具体表现键盘的 N 按下去没反应，需要大力出奇迹才能打出字母， 按照惯例，第一时间录下视频作为证据 这种问题很有可能会在第二天自动恢复，我这里就是，所以要留下证据，非常重要‼️ 预约维修第一次出现问题时没太在意，就录了个视频也就没管， 好巧不巧，前几天晚上又遇到了，赶紧预约了第二天的天才吧。 跟天才吧的天才交流当天早上，问题又“自动修复”了😂，所以说录视频很重要‼️， 天才吧里的天才按了很久也没能成功复现，但是也没有因此说电脑没问题（不像某品牌那么傲慢）， 最后是把 N 键拆开之后直接触碰触点复现了一个我从来没有遇到的问题😂 我遇到的问题是：按下去没反应 他测试出来的是：按下去之后反应两下😂 既然这样，那就维修呗，更换了整个键盘总成和上壳套件。 包括 键盘、Touch Bar、Touch ID、触控板、掌托一直到USB-C的外壳 以及 电池。 约等于 换了半台新电脑， 后面就是签个字，跑个诊断，就欧了～ 我的整个更换的周期是1天半。 新换的套件都带 90 天保修。 也总算是给我换到电池了！满血复活！！ 谈谈售后售后的目的就是让消费者放心的去使用自己购买的产品， 如果你有潜在的质量问题，给予客户这样的召回保修是很有必要的， 之前我的 Apple Pencil 出现了插在 iPad 上反向充电（越充越少）的问题， 在现场不能复现，但是我录了视频，确实有这样的问题，他们也依然给我做了更换， 就觉得苹果在这方面做的特别好，真真切切的帮助客户尝试解决问题（更换之后也确实是没再出现过这个情况了）， 但是这绝对不是意味着可以这样子去骗保，这是我的底线。 最近也在各大平台上也看到了华为拒保 Pocket S 屏幕质量问题的案例， 很多人明明没有认为损坏，就是一点点掉漆都被认定为人为损坏拒保了， 只能说，割韭菜割的真爽…","link":"/macbook-pro-keyboard-repair/"},{"title":"Magic Keyboard 使用体验","text":"买了 Apple Magic Keyboard 已经一周多了，体验了苹果的「线上买，线下提」， 经过一番折腾，又体验了「14天无理由退货」， 来分享下我的使用感受和折腾过程。 选购为什么会买？主要是因为我宿舍的桌子上放了电脑之后，没足够空间写作业了，一张 A4 纸都放不平， 于是， 就买了个增高架，电脑被抬高了，键盘触控板用起来就不顺手了， 所以，就要配一把键盘。 为什么是 Magic Keyboard 呢？市面上的键盘普遍要 200+ 左右，质量参差不齐， 同时，我也不是很习惯机械键盘的手感， 考虑到以后也可能会使用 Mac mini， 于是，就决定一步到位，买了这把 Magic Keyboard，感受下剪刀脚键盘。 体验「线下提货」这是 Apple 去年开始的一个新的购物选择，让你更快地拿到产品。 Apple Store 下单，等待邮件提醒可取货，去线下取货就行。 因为当下不是新品发售，而键盘也是属于配件一类，所以不存在缺货的情况。 从我到店，到拿到 Magic Keyboard，整个过程不超过 3 分钟，还是非常迅速的。 迅速地完成了配对，测试了下按键功能正常就高高兴兴地走了。 按键手感我个人是更加习惯键程短的薄膜键盘的，打字时有肌肉记忆，出错概率相对较低。 剪刀脚键盘的键程相较于蝶式键盘更长一些些，按键手感更软一些，整体还是比较舒服的。 Touch ID 按钮是那种开关的按钮的感觉，按下需要比其他按键更大的力气，不容易误触锁定。 连接性能 MacBook Pro 开盖自动休眠后，依然可以通过键盘唤醒电脑 MacBook Pro 开机时第一次输入密码时键盘自动连接，无需等待 MacBook Pro 开盖自动唤醒后，键盘保持连接 但是有时会出现打字没反应的情况，电脑显示键盘已连接，重新连接后恢复正常。 偶尔的，也能理解，正常。 功能按键刚拿到 Magic Keyboard 的时候是需要使用 fn + 功能按键 才能触发对应功能，且有些功能（勿扰、语音输入）无法使用。 后来在 macOS 设置中找到 “将F1、F2等键用作标准功能键”，关闭后按键全部可用，并且也不需要搭配 fn 了。 电池续航第一把键盘的续航完全尿崩，最夸张的是关闭键盘电源后一晚上耗电70%，不具备任何参考价值。 第二把键盘正常，高强度敲了两天半的代码，键盘保持开启，只耗电3%。 能够达到宣称的「一次充电，续航一个月」 我又把新的键盘充满了电，测测能用多久。 退换货经历轻微磕碰仅在测试按键功能，和第一次充电时揭开了外包膜，也基本没有使用过键盘。 到学校后无意间用指甲感受到 Option 键下方不平，才发现凹进去一块。 几乎可以排除认为造成，但是，这不是换货的主要原因。 续航问题、质量问题我认为第一把键盘的电池是有问题的。 第一次连接时，电池显示 0%，我以为就是正常的没电了。 没电了充呗。 当晚充满电，第二天早上就带去学校了，还剩 27% 😱 不到 12 小时啊，而且，键盘的开关是「关闭」的状态。 接下来的几天，我又针对性的进行了一些记录： 可以看出，无论是打开还是关闭键盘电源，都是有问题的，这就排除了我电脑连接、兼容性的问题了。 跟 400 客服沟通后，建议我无理由退货，再买一把新的（线下不能直接换货，好奇怪…）。 不过整个换货过程还是非常轻松愉快的，店员还跟我说，希望这把键盘没问题😂 经验与总结收到第二把键盘后，我仔细检查了外观，初始电池剩余容量（95%）。 回想起来，2023 年生产的键盘（盒子上写的），初始电量为 0% 确实不正常，下次也要注意检查这一部分。 对于 铝金属 且 有棱角的外壳，用指甲来检查是否平整，避免初始磕碰（这种问题很难证明不是后期人为造成） 总的来说，我仍然喜欢这把键盘，喜欢在 Apple 购物的体验， 没有什么废话，不跟你扯皮，该换就换，很喜欢这样的风格。","link":"/magic-keyboard-with-touchid-unbox/"},{"title":"Swift Data 的初步探索","text":"朋友们好，一周的考试结束了，我回来继续更新了，感觉考的不错，暑假里争取多更新一些。 今天的主题是 Swift Data – Core Data 的 Swift 化封装。 本文为 Meet Swift Data 的学习笔记。 模型借助 Swift 5.9 的 Macro，开发者可以很容易地创建一个数据模型，并可以将之以 @Observable 的方式注入 SwiftUI View 成为 Source Of Truth，并且与 @Observable 获得了一致的只刷新变化的值的特性。 在 Model 中，我们可以更加容易地使用自定义的 struct、enum 等之前在 Model Editor 中不好引入的自定义类型。 @Model 也支持模型与模型之前的关系和属性： @Attribute：设置 unique、externalStorage、spotlight 等属性。 @Relationship：自定义模型间的关系，从而确定诸如删除等操作的行为。 12345678910@Modelclass Trip { @Attribute(.unique) var name: String var destination: String var endDate: Date var startDate: Date @Relationship(.cascade) var bucketList: [BucketListItem]? = [] var livingAccommodation: LivingAccommodation?} 这段代码中： 确保了 name 字段的唯一性。 指定了 Trip 与 BucketListItem 之间的关系，即一旦 Trip 被删除，所有的 BucketListItem 也会被一并删除。 注入在 SwiftUI 中，在最简单的情况下，只需要在 ContentView 后加一句 .modelContainer(for: ) 即可。 但是在业务复杂的情况下，例如需要做数据库迁移或更新这类操作时，或者在其他环境下使用 Swift Data，你可能就需要一个 Container 容器来操作了。 创建的方法也很简单： 123456let container = try ModelContainer([Trip.self, LivingAccommodation.self])let container = try ModelContainer( for: [Trip.self, LivingAccommodation.self], configurations: ModelConfiguration(url: URL(&quot;path&quot;))) 获取 Container Context： 在 SwiftUI 下访问 Model Container：@Environment(\\.modelContext) private var context 如果不在 View 层级，例如在 ViewModel 中，可以使用 container.mainContext 来获得共享的主线程上下文 筛选Predicate、SortDescriptor 等之前晦涩难懂且不安全的 API 也更新了，可以更加 Swift 化地使用他们了。 获取数据变成了这样，更加直观了： 12345678let today = Date()let tripPredicate = #Predicate&lt;Trip&gt; { $0.destination == &quot;New York&quot; &amp;&amp; $0.name.contains(&quot;birthday&quot;) &amp;&amp; $0.startDate &gt; today}let descriptor = FetchDescriptor&lt;Trip&gt;(predicate: tripPredicate)let trips = try context.fetch(descriptor) 增、删、存12345678910var myTrip = Trip(name: &quot;Birthday Trip&quot;, destination: &quot;New York&quot;)// Insert a new tripcontext.insert(myTrip)// Delete an existing tripcontext.delete(myTrip)// Manually save changes to the contexttry context.save() 小结其实我是非常愿意使用新的 Swift Data 的，苹果应该也会在接下来的几个 Beta 中不断完善这个框架。 正如肘子老师在 WWDC.playground 中所说的，Swift Data 对于有一定 Core Data 基础的人来说使用起来非常简单，但是 Swift Data 目前也存在不少问题，而其中最致命的莫过于没有办法做向后兼容了，其次包括 iCloud 同步在内的很多功能都没法使用（这里的信息来自肘子老师的推文，我没有尝试 iCloud 的部分）。","link":"/meet-swift-data/"},{"title":"记录下 MarkdownView 的性能优化","text":"我的开源项目 MarkdownView 的 0.2.0 版本 终于发布了！ 改版本带来了性能上的巨大进步： Performance Rendering is now at least 3x faster on ALL DEVICES. Real-time previewing is now much much smoother. Scrolling is much quicker and smoother with no frame drop. Memory usage has been reduced by 30% 借此机会，记录下我的优化思路。 前期表现 启动、初次渲染耗时长 渲染完成后上下滚动的时候掉帧严重（使用懒加载模式） 渲染完成后上下滚动的时候内存占用量太大了（关闭了懒加载模式） 用作“实时预览”的时候会卡，导致输入体验很糟糕 综合以上表现，新功能部分也已经定型了，所以决定好好优化下性能， 至少在我这台 2019 款的 MacBook Pro 上不要有明显的卡顿吧… 渲染性能优化定位问题我想先来介绍下 MarkdownView 的整套渲染流程， 如图所示： 本来以为是在最后整合的时候 Layout 反复运算导致速度慢， 最后我用我第一篇博客测试了下，启动渲染居然需要 20s， 属于是完全卡住的感觉，在 Xcode 中能看到 CPU 占用持续在 100% 左右， 最后定位到 分词模块 耗费了大量 CPU 时间， 这就是优化的重点了！！ 问题分析分词模块的作用是保证文本都能以很短的形式呈现， 用于实现合理的自动换行， 但是分词模块依赖 Natural Language 框架进行分词， 本质上就是机器学习的分词，需要时间来完成， 同时所有的代码都是 同步执行（sync） 的， 上一个结束了才会执行下一个， 段落一多，大量的时间都被浪费在一段段分词了。 解决思路 异步执行（async）所有的分词操作，这样可以让所有段落的分词同时开始 文本渲染使用单独的 TextView 来渲染，默认显示空白等待分词结束后自动排版 还是用我的第一篇博客作为测试，加载速度从 20s 缩短到了 1s，内存占用也下降了 20%。 这也是我为什么会在新版中弃用 懒加载 (Lazy Loading) 的主要原因。 实时预览性能优化定位问题这里的问题具体表现在当我连续输入文本的时候， CPU占用高，并且伴随 输入框 也很卡顿。 问题分析接着上面的思路， 每次有微小变动的时候，MarkdownView 都会重新走整套流程， 本以为是异步处理得过于频繁导致卡顿， 于是就用Combine做了debounce处理，在输入间隙执行重新渲染， 问题没有解决， 而且，中文输入就没有问题， 重新考虑了下 渲染流程 和 SwiftUI 刷新机制， 每次有变动的时候，都要重新进入解析流程， 英文不论是多打一个字母或是删除一个字母，都会重解析， 中文输入拼音时本质上还没有让文本改变，不会重解析， 只有拼音转成文本之后，统一进行一次重解析， So， 在英文状态下，过于频繁的重解析是导致卡顿的“罪魁祸首”。 解决思路 对于一开始的文本输入做 debounce 处理，在输入间隙执行重解析、重渲染。 这样一来，在连续输入字符的时候不会每一次都执行重新解析和渲染， 只有在我输入时的停顿处，才会刷新整个文档，执行一次重渲染， 这样既保证了预览的实时性，也提升了整体性能。 做了debounce延迟，怎么保证预览的实时性？在真正地连续快速输入的情况下，是不会去看预览的 但凡少许停顿了下（0.3s），MarkdownView就已经自动刷新完成了 避免了在快速输入时，频繁地做无用的刷新 总结在开发过程中，需要注意： 对于一些比较耗时的部分（比如：下载、大量机器学习预测…）使用异步（async）来完成， 在 UI 出现问题时，关注下 UI 是如何刷新的， 看看是不是有过多繁杂的任务， 重新思考下现实中的逻辑，可以试着降低他们的优先级， 浓缩一下就是：主线程（main thread）不要有过多连续繁杂且无用的运算！！","link":"/markdownview-performance-optimization/"},{"title":"用 Apple Script 打开任务栏菜单","text":"（本文大部分为 ChatGPT 生成） 如果你是一个苹果电脑的用户，你可能已经习惯了使用任务栏菜单来快速地打开应用程序和执行其他的任务。但是，有时候你可能会感到很繁琐，因为每次打开任务栏菜单都需要通过鼠标点击来完成。但是，你可能不知道的是，你可以使用Apple Script来打开任务栏菜单，并以更快的方式访问它。 Apple Script 是一种编程语言，它可以用来自动化和控制Mac电脑中的各种操作。使用Apple Script，你可以编写脚本来执行各种任务，包括打开应用程序、发送电子邮件、自动化工作流程等等。 系统级菜单打开任务栏菜单是Apple Script的一项基本操作。下面是一个简单的示例脚本，用于打开任务栏菜单： 12345tell application &quot;System Events&quot; tell process &quot;SystemUIServer&quot; click (menu bar item 1 of menu bar 1) end tellend tell 在这个脚本中，我们使用了Apple Script的 tell 语句，它允许我们控制不同的应用程序和进程。我们首先使用 tell 语句告诉Apple Script要控制的应用程序是“System Events”。然后，我们再次使用 tell 语句告诉Apple Script要控制的进程是“SystemUIServer”，这是负责任务栏菜单的进程。 在最后一行中，我们使用了 click 命令来模拟点击任务栏菜单。具体来说，我们使用了 menu bar item 1 of menu bar 1 这个命令来定位任务栏菜单的位置，并将其作为 click 命令的参数。 要运行这个脚本，你可以将其保存到脚本编辑器中，并点击运行按钮。当脚本运行时，它会自动打开任务栏菜单，让你快速访问你需要的应用程序和功能。 总的来说，使用Apple Script来打开任务栏菜单是一个简单而有效的方法，可以大大提高你的工作效率。如果你是一个苹果电脑的用户，不妨尝试使用这个脚本来自动化你的日常操作。 （以上是 AI 生成，接下来，我来补充） 第三方 App如果你的系统是 macOS Ventura（其他系统的你可以尝试一下），那么 tell process &quot;SystemUIServer&quot; 只能获取到类似 Siri 这种的系统进程， 但是，我们的目标远不止如此。 想要控制第三方app，可以参考以下代码（代码由 ChatGPT 生成，并且实测可以实现我们的目标）： 1234567tell application &quot;System Events&quot; tell process &quot;APP名称&quot; click menu bar item 1 of menu bar 2 -- 点击第一个菜单项 click menu item 1 of menu 1 of menu bar item 1 of menu bar 2 end tellend tell 这里记得吧 “APP名称” 改下即可 这一部分我确实是不太会，问的 ChatGPT，它真的能给我正确的答案😱 理论上如果 App 是原生实现的（AppKit，SwiftUI，Catalyst 这种），都能用 Apple Script 控制， 可以用 entire contents 来打印出所有的内容，然后逐一查找， 网页套壳的（基于 Electron 框架，例如：新版QQ，抖音，B站这种）就算了。","link":"/open-menu-bar-extra-with-apple-script/"},{"title":"macOS 开发 -- URL 访问权限持久化（基于 Sandbox）","text":"好久不见，最近有在好好学习哈哈， 今天来分享下基于 Sandbox 的 URL 访问权限持久化的方案。 写这篇文章的起因是： 简单浏览了下 Tencent/lemon-cleaner 的部分源码， 发现他们用 Apple Script 调用 Finder 操作文件， 这样很好地避免了权限问题，但是研究一番发现，没那么简单…. Bookmark 大法这是我自己项目里使用的方法， 好处在于文件操作很自然， 不会让用户觉得自己的数据可以被随便乱翻（事实也确实是这样的） 将 App Sandbox –&gt; File Access 内的 User Selected File 改为 Read/Write 在项目的 entitlements 文件中添加这样一项 com.apple.security.files.bookmarks.app-scope，设为 YES 使用 NSOpenPannel / NSSavePannel 选择需要访问的文件（夹） 在 SwiftUI 中直接用 .fileImporter 之类的 modifer 就行 这样就拿到了用户选择的 URL 啦，因为是用户选择的，目前这个 URL 是有权访问的 注意，是目前，重启 app 就不行了 因此我们需要把权限持久化。 保存 URL 的 bookmark 1@AppStorage(&quot;bookmark&quot;) private var bookmark: Data? 12345do { bookmark = try url.bookmarkData(options: .withSecurityScope)} catch { print(error.localizedDescription) } （app 重启后）再次访问此 URL 1234567guard let bookmark else { return }var isStale = falselet url = try URL(resolvingBookmarkData: bookmark, options: .withSecurityScope, relativeTo: nil, bookmarkDataIsStale: &amp;isStale)url.startAccessingSecurityScopedResource()// Do some file-related works like move, duplicate, etc.// try? FileManager.default.moveItem(at: a, to: b)url.stopAccessingSecurityScopedResource() start 和 stop 一定要成对！！ 这里属于是访问系统敏感数据，如果不及时 stop 的话系统可能会对 app 的权限做限制， 因此不能滥用，这就是 Sandbox 为什么安全、让人放心的原因了。 url.startAccessingSecurityScopedResource() 也会返回一个布尔值，告诉你你是否真的可以这里的数据了，如果为 true 才能算成功。 Apple Script 大法Apple Script 实际上是代替用户操作的一种脚本，本质上是代替了手动的操作而已，因此这里可以操作所有文件了，在沙盒环境下当然是不会默认允许的。 如果启用了 Hardened Runtime，要先在里面启用 Apple Events，否则无法弹出请求框。 非 Sandbox如果在 非 Sandbox 环境下，只需要配置 Privacy - AppleEvents Sending Usage Description 告诉用户你执行的脚本的功能是干啥的就行。 然后就可以任意调用 applications了，例如，调用 Finder 来 move 文件之类的。 别慌！即使是非 Sandbox 也会有一步“自动化”授权的！ Sandbox在 Sandbox 环境下就会有限制了，不会让你能直接访问所有的 applications ，因为这可能会有潜在的恶意行为。 你还是得配置 Privacy - AppleEvents Sending Usage Description 告诉用户你执行的脚本的功能是干啥的， 你在需要使用对应的 applications 之前需要去 entitlements 里提前声明。（用到几个写几个） 1234&lt;key&gt;com.apple.security.temporary-exception.apple-events&lt;/key&gt;&lt;array&gt; &lt;string&gt;com.apple.Finder&lt;/string&gt;&lt;/array&gt; 这样你就可以在 app 中使用 NSAppleScript 执行脚本了。 否则，会报错 -600 因为是模拟用户操作的脚本，因此在移动文件、删除文件的时候都会有系统提示音哦～ 结尾目前我的项目中还是使用了 Bookmark 大法，更加简单，不会让用户觉得危险。 主要是 Apple Script 那些弹窗就蛮吓人了…","link":"/sandbox-url-persistence/"},{"title":"Swift Charts 入门 —— 认识各种标记","text":"最近在学习和使用 WWDC 22 上全新的 Swift Charts， Swift Charts 使用 SwiftUI 的声明式语法，用于在 SwiftUI 中构建可视化图表，便于数据的可视化分析。 本期博客将专注于 Swift Charts 的标记和符号。 开始创建图表在正式开始创建图表之前，需要先建立一个图表区域。 123456789import Chartsstruct ChartView: View { var body: some View { Chart { // ... } }} Marks 需要被放置在 Charts 内作为元素。 当有多个 Marks 重叠时，其表现形式类似于 ZStack。 你可以在创建 Chart 时直接导入数据，也可以在 Chart 内使用 ForEach 来导入数据。 标记（Mark）LineMark多个点连成一条线，简单直接。 123456789101112131415161718192021222324252627282930313233343536373839import SwiftUIimport Chartsstruct SunshineChart: View { var body: some View { Chart(data, id: \\.date) { LineMark( x: .value(&quot;Month&quot;, $0.date), y: .value(&quot;Hours of Sunshine&quot;, $0.hoursOfSunshine) ) } }}struct MonthlyHoursOfSunshine: Hashable { var date: Date var hoursOfSunshine: Double init(month: Int, hoursOfSunshine: Double) { let calendar = Calendar.autoupdatingCurrent self.date = calendar.date(from: DateComponents(year: 2023, month: month))! self.hoursOfSunshine = hoursOfSunshine }}let data: [MonthlyHoursOfSunshine] = [ MonthlyHoursOfSunshine(month: 1, hoursOfSunshine: 74), MonthlyHoursOfSunshine(month: 2, hoursOfSunshine: 99), MonthlyHoursOfSunshine(month: 3, hoursOfSunshine: 100), MonthlyHoursOfSunshine(month: 4, hoursOfSunshine: 110), MonthlyHoursOfSunshine(month: 5, hoursOfSunshine: 112), MonthlyHoursOfSunshine(month: 6, hoursOfSunshine: 125), MonthlyHoursOfSunshine(month: 7, hoursOfSunshine: 117), MonthlyHoursOfSunshine(month: 8, hoursOfSunshine: 112), MonthlyHoursOfSunshine(month: 9, hoursOfSunshine: 106), MonthlyHoursOfSunshine(month: 10, hoursOfSunshine: 102), MonthlyHoursOfSunshine(month: 11, hoursOfSunshine: 93), MonthlyHoursOfSunshine(month: 12, hoursOfSunshine: 78)] BarMark条状图，可以很清晰的展现出各个项目的数量多少。 123456789101112131415161718192021222324import SwiftUIimport Chartsstruct ContentView: View { var body: some View { Chart(data, id: \\.self) { BarMark( x: .value(&quot;Department&quot;, $0.department), y: .value(&quot;Profit&quot;, $0.profit) ) } }}struct Profit: Hashable { let department: String let profit: Double}let data: [Profit] = [ Profit(department: &quot;Production&quot;, profit: 15000), Profit(department: &quot;Marketing&quot;, profit: 8000), Profit(department: &quot;Finance&quot;, profit: 10000)] PointMark点标记，用于标定图标上的某一个或一系列点。 12345678910111213141516171819202122232425import SwiftUIimport Chartsstruct SunshineChart: View { var body: some View { Chart(data, id: \\.date) { LineMark( x: .value(&quot;Month&quot;, $0.date), y: .value(&quot;Hours of Sunshine&quot;, $0.hoursOfSunshine) ) PointMark( x: .value(&quot;Month&quot;, $0.date), y: .value(&quot;Hours of Sunshine&quot;, $0.hoursOfSunshine) ) } }}// MonthlyHoursOfSunshine &amp; data 和 LineMark 中的一致，就不再重复了//// struct MonthlyHoursOfSunshine { ... }//// let data = [ ... ] RuleMark基准标记，就是一条线，可以直观的展现出例如平均值、波动情况等数据。 1234567891011121314151617181920212223import SwiftUIimport Chartsstruct ContentView: View { var body: some View { Chart(data, id: \\.self) { BarMark( x: .value(&quot;Department&quot;, $0.department), y: .value(&quot;Profit&quot;, $0.profit) ) .opacity(0.3) RuleMark(y: .value(&quot;Average&quot;, 11000)) .lineStyle(StrokeStyle(lineWidth: 3)) } }}// Profit &amp; data 和 BarMark 中的一致，就不再重复了//// struct Profit { ... }//// let data = [ ... ] RectangleMark与 PointMark 类似，只是形状变成了矩形。 当然，他也可以被用来展示一个区域。 1234567891011121314151617181920212223242526272829303132import SwiftUIimport Chartsstruct ContentView: View { var body: some View { Chart(data, id: \\.self) { RectangleMark( xStart: .value(&quot;Rect Start Width&quot;, $0.x - 0.25), xEnd: .value(&quot;Rect End Width&quot;, $0.x + 0.25), yStart: .value(&quot;Rect Start Height&quot;, $0.y - 0.25), yEnd: .value(&quot;Rect End Height&quot;, $0.y + 0.25) ) .opacity(0.2) PointMark( x: .value(&quot;X&quot;, $0.x), y: .value(&quot;Y&quot;, $0.y) ) } }}struct Coord: Hashable { var x: Double var y: Double}var data: [Coord] = [ Coord(x: 5, y: 5), Coord(x: 2.5, y: 2.5), Coord(x: 3, y: 3)] AreaMark通过多个点组成线，并对其包裹的区域做填充，用来展示某一个区域。 如果是简单的矩形区域，也可以直接使用 RectangleMark。 例如：天气app中，每天的最高温、最低温区间。 1234567891011121314151617181920212223242526272829import SwiftUIimport Chartsstruct WeatherChart: View { var body: some View { Chart(data) { day in AreaMark( x: .value(&quot;Date&quot;, day.date), yStart: .value(&quot;Minimum Temperature&quot;, day.minimumTemperature), yEnd: .value(&quot;Maximum Temperature&quot;, day.maximumTemperature) ) .interpolationMethod(.catmullRom) } }}struct Weather: Identifiable { let date: Date let maximumTemperature: Double let minimumTemperature: Double let id: Int}let data = [ Weather(date: .now, maximumTemperature: 20, minimumTemperature: 10, id: 1), Weather(date: .now.addingTimeInterval(24 * 60 * 60), maximumTemperature: 25, minimumTemperature: 13, id: 2), Weather(date: .now.addingTimeInterval(2 * 24 * 60 * 60), maximumTemperature: 23, minimumTemperature: 12, id: 3), Weather(date: .now.addingTimeInterval(3 * 24 * 60 * 60), maximumTemperature: 24, minimumTemperature: 13, id: 4),] 符号（Symbol）如果涉及到多样本处理，例如：比较多个城市的气温曲线， 为了让图表看起来更加直观，通常会使用一些符号或者颜色来做区分。 有以下几种方式： 以颜色区分：foregroundStyle1234567Chart(data, id: \\.date) { LineMark( x: .value(&quot;Month&quot;, $0.date), y: .value(&quot;Hours of Sunshine&quot;, $0.hoursOfSunshine) ) .foregroundStyle(.value(&quot;City&quot;, $0.city))} 以形状区分：symbol1234567Chart(data, id: \\.date) { LineMark( x: .value(&quot;Month&quot;, $0.date), y: .value(&quot;Hours of Sunshine&quot;, $0.hoursOfSunshine) ) .symbol(.value(&quot;City&quot;, $0.city))} 创建之后在图表左下角会出现 Legend， 通过上述的两个 modifiers 也可以自定义颜色和形状，都会展示在 Legend 中。 如果想隐藏 Legend，可以使用 .chartLegend(.hidden)","link":"/swift-charts-intro-marks/"},{"title":"探索 Swift Concurrency (1)","text":"Swift 并发是 WWDC 21 上的一个重磅改进，提供了 async/await 的语法， 让代码结构更加流程化，更加便于理解和调试。 官方指南：开始使用 Swift 并发 actor WWDC Sessions： 利用 Swift 并发消除数据争用 利用 Swift Actor 保护可变状态 actor 和 class 很相似，都是 Ref Type。 但是 Actor 保证了内部数据的唯一性，即一次只有一个函数能调用， 如果有多个函数同时调用该属性，则需要排队。 保证了在并发环境下的数据竞争 (Data Races)。 其用法与 struct/class 一致。 Main Actor WWDC Session：利用 Swift Actor 保护可变状态 简单理解就是：主线程。 所有的 UI Updates 都需要在 Main Actor 环境下完成。 有以下几种写法： 123Task { @MainActor in // UI Updates} 123@MainActor func updateUI() { // UI Updates} 12345Task { await MainActor.run { // UI Updates }} 12345678910111213@MainActorclass ViewModel: ObservableObject { @Published var show = false func fetch() async { let data = ... updateUI() // Run on the MainActor because the whole class is in MainActor. } func updateUI() { // UI Updates }} async let WWDC Session：探索 Swift 中的结构化并发 async let 可以让多个操作一起执行，到真正需要使用的时候再 await。 12345678910111213141516func fetchImage() async { // Fetching Image}func fetchMetaData() async { // Fetching Meta Data}async let image = fetchImage() // Start fetching while the CPU is free.async let metaData = fetchMetaData() // The same as image.// Do other work...// Display the image and backup.display(await image)backup(await metaData) // This is just an example...haha 这个例子中，如果只用 await，image 和 metaData 会依次获取，在获取期间程序挂起 (Suspended)，不会继续向下执行。 如果 image 的获取比较慢，那么就会卡在这里。 123456789101112func fetchImage() async { }func fetchMetaData() async { }let image = await fetchImage() // It's stuck here.😅let metaData = await fetchMetaData() // As well as here.😅// Do other work...// Because we were stuck before, so we waste a large amount of time.// Display the image and backup.display(image)backup(metaData) // This is just an example...haha Task Group WWDC Session：探索 Swift 中的结构化并发 多个任务并发执行的时候可以使用 Task Group 123456789101112131415161718192021// Throwing Task GroupTask.detached { await withThrowingTaskGroup(of: Void.self) { group in for task in self.tasks { group.addTask { try await ... } } }}// Non-Throwing Task GroupTask.detached { await withTaskGroup(of: Void.self) { group in for task in self.tasks { group.addTask { await ... } } }} TaskGroup 常用在一组数据的处理，例如：获取所有商品的缩略图… 由于有很多 tasks 同时执行，因此就会有潜在的 Data Races 我们不能直接对外部的变量赋值（这是一个编译时检查错误） 1234567891011121314151617181920var integers = [Int]()// Throwing Task Groupfunc foo() { Task.detached { try await withThrowingTaskGroup(of: Int.self) { group in for _ in 0...10 { group.addTask { // Return some values here. return (0...100).randomElement()! } } // Read values from the group. for try await value in group { self.integers.append(value) } } }} Non-Throwing Task Group 方法一致，这里就不再演示了。 这里使用 Task.detached 是为了防止受到 Context 的影响， 例如：下载所有商品的缩略图应在其他线程上完成，而非主线程。 往下看就知道我在说什么了。 Task vs. Task.detached WWDC Session：探索 Swift 中的结构化并发 相关文章：What’s the difference between a task and a detached task? Task 提供了一种 async 的环境来执行异步操作。 Task: Runs the given nonthrowing operation asynchronously as part of a new top-level task on behalf of the current actor. Task.detached: Runs the given throwing operation asynchronously as part of a new top-level task. Task 会继承当前的 Context 和 Priority， Honestly，这句话我理解了很久，Priority好理解，但是 Context 是什么？ 12345678910111213141516171819@MainActorclass TaskManager1 { func doWorks() { Task { print(&quot;Execute on main thread: \\(Thread.isMainThread)&quot;) // true } Task.detached { print(&quot;Execute on main thread: \\(Thread.isMainThread)&quot;) // false } }}class TaskManager2 { func doWorks() { Task { print(&quot;Execute on main thread: \\(Thread.isMainThread)&quot;) // false } }} 诸如线程之类的属性就是所谓的 Context。 也就是说上层的运行环境会被继承到 Task 中来，如果不想要这种继承，使用 Task.detached 需要注意的是，使用 Task.detached 需要显式捕获 self，即 self.variable Task + ObservableObject WWDC Session：探索 Swift 中的结构化并发 相关文章：What’s the difference between a task and a detached task? 在 SwiftUI 中，很多情况下我们会使用 @ObservedObject 或者 @StateObject 来管理 ViewModel 这时候，该视图就会在 MainActor 下执行。 12345678910Task { for i in 0...1000 { print(&quot;Task 1: \\(i)&quot;) }}Task { for i in 0...1000 { print(&quot;Task 2: \\(i)&quot;) }} 上面的例子中，你会发现控制台中 Task 1 和 Task 2 仍然会按次序执行。 这是因为 @ObservedObject 或者 @StateObject 限制了视图运行在 MainActor 上， 所有的更新都发生在主线程，而 Task 会继承 Context，因此这时候可以使用 Task.detached 12345678910Task.detached { for i in 0...1000 { print(&quot;Task 1: \\(i)&quot;) }}Task.detached { for i in 0...1000 { print(&quot;Task 2: \\(i)&quot;) }} 都换成 Task.detached 之后，Task 1/2 就是一起执行了，也不会都挤在主线程上跑了。 nonisolated 相关文章：How to make parts of an actor nonisolated 还记得最开始的 actor 吧， 多个函数调用它的时候只有其中一个能执行，其余的等待上一个执行完成再进入， 这被称为隔离，很有效地避免了 Data Races 但是并非 actor 中所有的函数、属性都需要被隔离开。 对 actor 扩展 Hashable 协议时，hash(into hasher: inout Hasher) 不支持 async/await WWDC Session：利用 Swift Actor 保护可变状态 123456789101112131415actor MyHashableActor { let staticValue = 0 var variable = 1}extension MyHashableActor: Hashable { static func == (lhs: MyHashableActor, rhs: MyHashableActor) -&gt; Bool { return true // Comforms to Equatable } nonisolated func hash(into hasher: inout Hasher) { hasher.combine(staticValue) hasher.combine(variable) // 🙅 // This is an error because variable is mutable // and the `hash(into hasher: inout Hasher)` is nonisolated. }} actor 内部的函数的其中一部分可以并发执行，充分利用多核性能。 WWDC Session： Swift 并发的可视化与优化 123456789101112131415161718192021222324252627actor Compressor { var state = true // Since the function is nonisolated // and we still need to update the state, // so, the `compressFile()` funtion is marked `async`. // Now, the programme will only be blocked when updating the state. nonisolated func compressFile(_ file: File) async -&gt; Data { await updateState() // Blocked here to avoid Data races. let data = compress(file) // This operation can be ran simultaneously. await updateState() // Also blocked here to avoid Data races. return data } func updateState() { state.toggle() }}let compressor = Compressor()for file in files { Task.detached { let data = await self.compressor.compressFile(file) }}func compress(_ file: File) -&gt; Data { // Compress file.} 执行逻辑（个人理解） WWDC Session：Swift 并发功能：幕后故事 @MainActor 中的 Task Task 中的操作均由 主线程 完成，继承 MainActor 遇到 await 时， 程序被挂起，待执行的代码被迁移到其他线程（根据 priority 依次执行），主线程释放，供其他需要在主线程运行的代码继续。 await 结果可用之后，仍呆在原地，等待主线程空闲，之后回到主线程，恢复之前的状态继续向下执行。 非 @MainActor 中的 Task Task 中的操作均会在 其他线程 中完成，继承上层的 Context 后两点与上一条基本一致 Task.detached 会创建一个新的线程来完成操作。","link":"/swift-concurrency/"},{"title":"SwiftUI 中的 Conditional Scene","text":"在 SwiftUI 中，有时需要对新的 API 做隔离来保证兼容老的系统。 在 View 中很好解决，但是在 Scene 中，你可能会看到这样的错误提示。 Closure containing control flow statement cannot be used with result builder ‘SceneBuilder’ 2023.2.17更新在 Xcode 13.4 beta 中，SceneBuilder 支持了 buildExpression，buildLimitedAvailability 和 buildOptional。 解决思路解决方法就是把需要用条件判断给出不同的 Scene 的部分单独写成一个函数， 返回 some Scene，同时不要使用 @SceneBuilder body 中默认使用 @SceneBuilder 来支持多个 Scene 在 if-condition 中返回的可能是两个不同类型的 Scene，但是函数的返回值是不透明的 some Scene，因此只要返回的内容是符合 Scene 协议的就可以。 可以参考我在 stackoverflow 上的回答 最后，上代码！ 12345678910111213141516171819202122232425262728293031323334@mainstruct YourApp: App { var body: some Scene {#if os(macOS) // macOS conditionalWindowScene().windowStyle(.hiddenTitleBar)#else // Other Platform WindowGroup { ContentView() }#endif }#if os(macOS) /// Extract your conditional scene to avoid using `@SceneBuilder` /// In `body`, SwiftUI will always use `@SceneBuilder` to build multiple Scene. /// Because the result type is `some Scene`, /// you just need to return a type that conforms to `Scene` Protocol. func conditionalWindowScene() -&gt; some Scene { if #available(macOS 13.0, *) { /// `Window` Scene is only available on macOS 13.0+ return Window(&quot;App&quot;, id: &quot;MAIN&quot;) { ContentView() } } else { /// Otherwise, using `WindowGroup` return WindowGroup { ContentView() } } }#endif}","link":"/swiftui-conditional-scene/"},{"title":"Selection Range in SwiftUI","text":"在 SwiftUI 中，没有提供默认的 modifier 来监听 TextView 的 selectionRange， 这对于文本编辑类 app 来说是很致命的，因为无法控制光标的位置， 但是可以从其他的文章中找到一些思路： The Power of the Hosting+Representable Combo siteline/SwiftUI-Introspect 寻找 NSView / UIView 的方法来源于：siteline/SwiftUI-Introspect 本文来介绍一种解决方案，可以实现出以下的代码： 1234567891011import SwiftUIstruct Example: View { @State private var selectionRange = NSRange() @State private var text = &quot;&quot; var body: some View { TextEditor(text: $text) .selectionRange($selectionRange) }} 原理首先从 SwiftUI 的底层入手， SwiftUI 在构建 View 时会使用到 NSView(Controller) / UIVIew(Controller)， 在他们的上层还会包一层 ViewHost， 类似这样： 只要我们顺着 ViewHost 找到了对应的 NSView(Controller) / UIVIew(Controller)， 就能实现对控件的自定义更改。 代码实现STEP 1: 寻找 NSTextView / UITextView12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152fileprivate class _TextViewFinder: PlatformView { init() { super.init(frame: .zero) isHidden = true } public override func hitTest(_ point: NSPoint) -&gt; PlatformView? { return nil } @available(*, unavailable) required init?(coder: NSCoder) { fatalError(&quot;init(coder:) has not been implemented&quot;) } func findTextView(view: PlatformView?) -&gt; TextView? { var superview = view while let s = superview { if NSStringFromClass(type(of: s)).contains(&quot;ViewHost&quot;) { let viewHost = s guard let superview = viewHost.superview, let entryIndex = superview.subviews.firstIndex(of: viewHost), entryIndex &gt; 0 else { return nil } for subview in superview.subviews[0..&lt;entryIndex].reversed() { if let typed = findChild(in: subview) { return typed } } return nil } superview = s.superview } return nil } private func findChild(in root: PlatformView) -&gt; TextView? { for subview in root.subviews { if let typed = subview as? TextView { return typed } else if let typed = findChild(in: subview) { return typed } } return nil }} 1234567#if os(macOS)fileprivate typealias TextView = NSTextViewfileprivate typealias PlatformView = NSView#elseif !os(watchOS)fileprivate typealias TextView = UITextViewfileprivate typealias PlatformView = NSView#endif STEP 2: 把 PlatformView 包装成 SwiftUI View1234567891011121314151617fileprivate struct _TextViewFinderWrapper: ViewRepresentable { @Binding var textView: TextView? typealias _Finder = _TextViewFinder func makeView(context: Context) -&gt; _Finder { _TextViewFinder() } func updateView(_ finder: _Finder, context: Context) { DispatchQueue.main.async { if let textView = finder.findTextView(view: finder.superview) { self.textView = textView } } }} 1234567891011121314151617181920212223242526272829#if os(macOS)protocol ViewRepresentable: NSViewRepresentable { associatedtype NSViewType func makeView(context: Context) -&gt; NSViewType func updateView(_ nsView: NSViewType, context: Context)}extension ViewRepresentable { func makeNSView(context: Context) -&gt; NSViewType { makeView(context: context) } func updateNSView(_ nsView: NSViewType, context: Context) { updateView(nsView, context: context) }}#elseprotocol ViewRepresentable: UIViewRepresentable { associatedtype UIViewType func makeView(context: Context) -&gt; UIViewType func updateView(_ uiView: UIViewType, context: Context)}extension ViewRepresentable { func makeUIView(context: Context) -&gt; UIViewType { makeView(context: context) } func updateUIView(_ uiView: UIViewType, context: Context) { updateView(uiView, context: context) }}#endif 利用 finder.findTextView 寻找 TextView 并且将其保存到 textView， 使用 @Binding 可以使其生命周期与视图保持同并与上层视图同步信息。 STEP 3: 用 _TextViewFinderWrapper 来寻找对应的 NSView / UIViewoverlay 相当于 AppKit 和 UIKit 中的 addSubview， 使用 superview 即可找到上层的 ViewRepresentation 也就是 SwiftUI View， 可以写一个 ViewModifier 123456fileprivate struct _SelectionRangeModifier: ViewModifier { func body(content: Content) -&gt; some View { content .overlay(_TextViewFinderWrapper(textView: $textView).frame(width: 0, height: 0)) }} STEP 4: 实现 selectionRange 的双向绑定向上绑定： 123456.onReceive( NotificationCenter.default.publisher(for: TextView.didChangeSelectionNotification, object: textView)) { _ in // Selection Range did change. // Update selection range using `textView` instance.} 向下绑定： 123.task(id: range) { // Selection range changed by SwiftUI State.} 封装起来大致是这样的： 12345678910111213141516171819202122232425fileprivate struct _SelectionRangeModifier: ViewModifier { @Binding var range: NSRange @State private var textView: TextView? func body(content: Content) -&gt; some View { content .overlay(_TextViewFinderWrapper(textView: $textView).frame(width: 0, height: 0)) #if os(macOS) .onReceive( NotificationCenter.default.publisher(for: TextView.didChangeSelectionNotification, object: textView) ) { _ in guard let textView else { return } range = textView.selectedRange() } #endif .task(id: range) { let newRange = range #if os(macOS) textView?.setSelectedRange(newRange) #else textView?.selectedRange = newRange #endif } }} STEP 5: 扩展一下 View1234567extension View { @available(watchOS, unavailable) @available(iOS 13.0, macOS 10.15, tvOS 13.0, *) func selectionRange(_ range: Binding&lt;NSRange&gt;) -&gt; some View { modifier(_SelectionRangeModifier(range: range)) }} 好啦，搞定！ 小问题 本方法属于 Hack，很有可能在未来的 SwiftUI 大版本中失效（如果 SwiftUI 修改了 View Hierarchy） 文本框还是可能会出现闪烁的问题，我已经尽可能地规避了，但是可能还是会出现…目前无解。","link":"/swiftui-selection-range/"},{"title":"MarkdownView 从 0 到 1 —— 回顾整条时间线","text":"熟悉我的朋友应该知道，我一直在开发一个框架， 用于在 SwiftUI 中以原生的方式来渲染 Markdown 文本。 P.S. 这篇文章也是在我做的编辑器中完成的。 早晨发布了 MarkdownView 的 1.0.0-rc，也就是正式版的候选版本， 写这篇文章主要是想回顾和总结一路过来的技术点和一些解决方案。 为什么要做这个项目无奈和机遇其实，很早之前，我就想做一款笔记应用， 写字功能用 PencilKit 能实现，但是总不能只支持手写吧… 但是找了一圈开源社区都找不到很好的用于渲染 Markdown 文本的组件， 恰好在我高考完之后，发现苹果开源了自己的 swift-markdown 用于处理 Markdown 文本的解析。 Typora 结束公测，开始收费其实是有替代的 Notion，但是 Web 套壳的 app 多少还有点不喜欢，而且访问也不是很稳定。 基本原理先来说说 swift-markdown 解析好的数据是如何变成最终的 View 的： 原始文本由 swift-markdown 解析生成文档树 对应每一个节点，返回一个原生的 SwiftUI View 用合适的方法将所有节点的 View 合并在一起打包 由 SwiftUI 计算和显示 在第二步中返回的每一个子 View 都需要是相同类型的，不过好在 SwiftUI 给我们提供了 AnyView 来擦除类型。 布局问题由于文档树中的每一个节点都是一个 AnyView，面临两个问题： 如何控制每一个视图的大小 如何动态的使用 HStack 和 VStack 来放置横竖两个方向 幸运的是，在 WWDC 22 上，我们可以自定义一个 Layout， 但不幸的是，Layout Protocol 只支持最新的系统，无法向后兼容。 拆分文本，再结合除了图片之外的内容，归根结底都是文本， 因此将文本拆分成尽可能小的部分（一个单词或者一个词组） 配合自定义的灵活布局（FlowLayout）来实现布局。 但是这样的方案属于在运行时拆分（文本）又合并（视图），非常消耗系统资源。 之前的 记录下 MarkdownView 的性能优化 中提到的解决方案只能解决启动时的卡顿和连续输入时的卡顿， 而对于内容的加载速度没有帮助，同时多个异步操作也需要等待 CPU 空闲时才能被派发上去。 最关键的是，按照这样的模式继续下去，文本始终无法选择和复制。 将视图暂存，合并相同的类型主要想要解决的问题是 加载时间长 和 无法复制 这两个问题。 加载时间长主要是因为频繁地文本拆分和大量的子视图的位置大小计算导致的， 解决方案是使用 SwiftUI 中的 Text 做拼接，同时解决了无法复制的问题，顺便可以向后兼容了一个大版本。 这一块的灵感是受到 在 SwiftUI 中用 Text 实现图文混排 的启发。 创建了一个 ViewContent 用来暂存由节点生成的视图： 123456789struct ViewContent { var text: Text var view: AnyView var type: ContentType enum ContentType: String { case text, view }} 当传入多个 ViewContent 的时候，会检查并合并相邻的、同类型的 ViewContent， 后面再用 VStack 把一个个的 paragraph 串起来即可得到完整的视图， 测试了下，同一文档的加载速度提升了约 5x 图片和自定义块的支持通过 ImageDisplayable 和 BlockDirectiveDisplayable，允许开发者自己定义如何显示相关内容， 学习了类型擦除的实现方案。 AdaptiveGrid由于向后兼容了一个大版本导致无法直接使用新的 Grid 组件， 因此，还需对老版本系统提供一个类似的视图， 于是写了一个 AdaptiveGrid，其表现行为与 Grid 几乎一致。 后面我应该会再写一篇博客来说说其背后的实现原理。 学习了 @resultBuilder 的构建，在这里再次感谢肘子哥的两篇博客： ViewBuilder 研究（上）—— 掌握 Result builders ViewBuilder 研究（下） —— 从模仿中学习 SVG 增强一直以来，SVG 的渲染都是由 SVGKit 来处理的， 但是问题是，有编译警告、 Package 过于臃肿 且 部分SVG无法正确渲染。 最近改用了原生的 WKWebView 来渲染 SVG（相当于一个网页） 学习了如何使用 JS 来获取网页元素的大小，以此来作为最终整个 SVG 的大小， 并且能够根据可用宽度来自动判断是否启用滚动条等等… 具体的实现可以在代码中找到，我不在做过多的赘述。 总结道路不是一帆风顺的，总要在跌跌撞撞中成长， 但庆幸的是，这个自主项目，我做出了自己满意的样子，耶～ 项目地址：Github OR Swift Package Index","link":"/the-road-of-markdown-view/"},{"title":"Swift 中的类型擦除（下）—— 从模仿中学习","text":"上篇博客中，我们初步了解了为什么需要一个 Type Eraser ， 也分享了一个简单实现 Type Erasure 的方案。 为了更加深入了解类型擦除，我们还是得来看看 Swift 自带的一些 Type Eraser 是如何实现的。 目标是：理解一下其基本思路，并且仿制一个出来。 底层原理为了方便理解，我们聚焦于一个 Type Eraser：AnyIterator 为什么是它呢？ 因为它出现在源码的最上面😂，而且下面的 AnySequence 和 AnyCollection 都得回到 AnyIterator。 先看源码（我这里去除了注释和一些不太重要的代码，方便大家阅读）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@inline(never)@usableFromInlineinternal func _abstract( file: StaticString = #file, line: UInt = #line) -&gt; Never { fatalError(&quot;Method must be overridden&quot;, file: file, line: line)}public struct AnyIterator&lt;Element&gt; { @usableFromInline internal let _box: _AnyIteratorBoxBase&lt;Element&gt; @inlinable public init&lt;I: IteratorProtocol&gt;(_ base: I) where I.Element == Element { self._box = _IteratorBox(base) }}extension AnyIterator: IteratorProtocol { @inlinable public func next() -&gt; Element? { return _box.next() }}@_fixed_layout@usableFromInlineinternal class _AnyIteratorBoxBase&lt;Element&gt;: IteratorProtocol { @inlinable // FIXME(sil-serialize-all) internal init() {} @inlinable // FIXME(sil-serialize-all) deinit {} @inlinable // FIXME(sil-serialize-all) internal func next() -&gt; Element? { _abstract() }}@_fixed_layout@usableFromInlineinternal final class _IteratorBox&lt;Base: IteratorProtocol&gt; : _AnyIteratorBoxBase&lt;Base.Element&gt; { @inlinable internal init(_ base: Base) { self._base = base } @inlinable // FIXME(sil-serialize-all) deinit {} @inlinable internal override func next() -&gt; Base.Element? { return _base.next() } @usableFromInline internal var _base: Base} 整理一下，一共用到两个类，_AnyIteratorBoxBase（基类） 和 _IteratorBox（中转类） 基类符合协议，并且用一些占位符做好填充（需要在中转类中重写这些方法） 中转类继承自基类，并从外部接收一个符合协议的实例，用来重写（覆盖）基类中的方法和属性。 最后，用一个对外的 Type Eraser 再做一次中转。 仿制过程中的一些坑123456789101112// MARK: - Protocol and Type Eraserprotocol MyCollection { … }struct AnyMyCollection&lt;Element&gt; { … }extension AnyMyCollection: MyCollection { … }…// MARK: - Custom Typesstruct Animals: MyCollection { … }struct Digits: MyCollection { … }// MARK: - Type Erasure// ❌ Heterogeneous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentionalvar collections = [AnyMyCollection(Animals()), AnyMyCollection(Digits())] 首先，我注意到的是类型推断的问题， 可以尝试下 AnyCollection，AnyIterator 这些，发现 collections 中的 Element 变成了 Any， 也就引出了第一个问题。 Swift 的特性之一：类型推断12345678// Type: AnyIterator&lt;Int&gt;AnyIterator([1, 2, 3].makeIterator())// Type: AnyIterator&lt;String&gt;AnyIterator([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].makeIterator())// Type: [AnyIterator&lt;Any&gt;][AnyIterator([1, 2, 3].makeIterator()), AnyIterator([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].makeIterator())] 这俩东西的 Element 类型不一致，为什么放在一起还能编译并且 Element 变成 Any 了呢？ 实际上，是 Swift 的类型推断在干活 而如果换一种写法： 1234let intIterator = AnyIterator([1, 2, 3].makeIterator())let stringIterator = AnyIterator([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].makeIterator())let together = [intIterator, stringIterator] // ❌ Heterogeneous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentional 就会报错，原因就在于这两个东西的类型不一致，不能放在一个 Array 里， 提前声明的话，编译器会固化类型，是什么就是什么 AnyIterator&lt;String&gt; 和 AnyIterator&lt;Int&gt; 是两种不同的类型，它们的 Element 不同 更加详细的可以看我问的这个帖子：AnyCollection with different generic types 对 Array 再做一个扩展，让任何数组都符合协议。 12345extension Array: MyCollection { func allValues() -&gt; [Element] { self }}let arrayCollection = [AnyMyCollection([1, 2, 3]), AnyMyCollection([&quot;a&quot;, &quot;b&quot;])] // ✅ AnyMyCollection&lt;Any&gt; 这里的两个类型分别是：AnyMyCollection&lt;Int&gt; 和 AnyMyCollection&lt;String&gt; 但是再加上 Digits 却报错了。 12// ❌ Heterogeneous collection literal could only be inferred to '[Any]'; add explicit type annotation if this is intentionallet collection = [AnyMyCollection(Digits()), AnyMyCollection([1, 2, 3]), AnyMyCollection([&quot;a&quot;, &quot;b&quot;])] 这就是第二个问题。 编译时推断 和 运行时推断分析一下每一个 AnyMyCollection 的类型： 12345678// AnyMyCollection&lt;Digits.Element&gt;AnyMyCollection(Digits())// AnyMyCollection&lt;Int&gt;AnyMyCollection([1, 2, 3])// AnyMyCollection&lt;String&gt;AnyMyCollection([&quot;a&quot;, &quot;b&quot;]) 按照之前说的，应该统一成 AnyMyCollection&lt;Any&gt; 才对， 但是，仔细观察能够发现，传入 AnyMyCollection 的类型分别是 Digits, Array&lt;Int&gt; 和 Array&lt;String&gt;， 第一个不带泛型，而其他的均带泛型， 对于 Array&lt;Element&gt; 来说，编译时是可以确定 Element 的具体类型的, 且 Array 中的 Element 和 MyCollection 中的 Element 是一致的， 因此，编译时可以确定出 AnyMyCollection 中的 Element（即 Array 中的 Element）的类型。 但对于 Digits 来说，由于其本身没有泛型，所以 Element 事实上是被“隐藏”起来的， 编译器无法推断其类型，因此不能自动变成 Any。 直到运行时才能确定出 Digits.Element 的具体类型是 Int 有解决办法嘛？有。 就是给 Digits 加上 Element 的泛型。 但是加上泛型再去限定只能是 Int 就有点脱裤子放屁的感觉了😂 最终我把它变成了一个 CustomCollection 123456789101112struct CustomCollection&lt;Element&gt; { internal var content: [Element] = [] init(_ content: Element...) { self.content.append(contentsOf: content) }}extension CustomCollection: MyCollection { func allValues() -&gt; [Element] { content }} AnyMyCollection上面两个问题研究透彻之后，从 Protocol 到 Type Eraser 的仿制也就完成了。 最终代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protocol MyCollection&lt;Element&gt; { associatedtype Element func allValues() -&gt; [Element]} // MARK: - AnyMyCollectionstruct AnyMyCollection&lt;Element&gt; { internal var _box: _AnyMyCollectionBase&lt;Element&gt; init&lt;C: MyCollection&gt;(_ base: C) where Element == C.Element { _box = _MyCollectionBox(base) }}extension AnyMyCollection: MyCollection { func allValues() -&gt; [Element] { _box.allValues() }}final class _MyCollectionBox&lt;Base: MyCollection&gt;: _AnyMyCollectionBase&lt;Base.Element&gt; { init(_ base: Base) { _base = base } private var _base: Base override func allValues() -&gt; [Base.Element] { return _base.allValues() }}class _AnyMyCollectionBase&lt;Element&gt;: MyCollection { func allValues() -&gt; [Element] { fatalError(&quot;This method should be overwritten. Line 35.&quot;) }}extension Array: MyCollection { func allValues() -&gt; [Element] { self }}// - MARK: Custom Collectionstruct CustomCollection&lt;Element&gt; { internal var content: [Element] = [] init(_ content: Element...) { self.content.append(contentsOf: content) }}extension CustomCollection: MyCollection { func allValues() -&gt; [Element] { content }}var collections = [AnyMyCollection(CustomCollection(1, 2, 3)), AnyMyCollection([&quot;a&quot;, &quot;b&quot;])] 总结整个过程耗费了差不过两天的时间，最重要的是要理解这一种 Type Eraser 的基本原理和实现， 踩踩坑，更能加深印象🥲 不过 Swift 5.7 有了 any 关键字，不知道能不能取代掉 Type Eraser，期待一下 Swift 6。","link":"/type-erasure-in-swift-2/"},{"title":"Swift 中的类型擦除（上）—— 为什么 &amp; 怎么做","text":"探索类型擦除的原理和实现，常见的类型橡皮擦有：AnyView、AnyShape、AnyCollection… 1234protocol Tool { associatedtype S: StringProtocol func name() -&gt; S} 通过这个协议（或者叫接口）可以创建一个 Tool 1234567891011121314151617struct Pen: Tool { func name() -&gt; some StringProtocol { &quot;Pen&quot; }}struct Pencil: Tool { func name() -&gt; some StringProtocol { &quot;Pencil&quot; }}struct Ruler: Tool { func name() -&gt; some StringProtocol { &quot;Ruler&quot; }} 接下来，我要创建一个 ToolController 来管理我的“工具们”， 123class ToolController {} 我们先来获取所有工具，但是遇到一个问题， 这里虽然只有三个工具，可以一个个写， 但是这只是个例子，在实际应用中这里的数量是未知的， 应该如何获取所有的工具呢？大致思路是这样的。 1let tools: [Tool] = [Pen(), Pencil(), Ruler()] 但是，Tool 中有 associatedtype，因此 Tool 不能当作类型来使用， 好消息是，在 Swift 5.7 或更新版本中，可以使用 any Tool 来作为类型， 但是之后的所有结果都带有 any，可能不会是你预期的结果。 比如 any View 不符合 View 协议… 除了这样的数组创建和使用上可能会受阻，在多分支返回是也会出问题。 123456789101112class ToolController { var currentTool = &quot;pen&quot; // ❌ Function declares an opaque return type 'some Tool', but the return statements in its body do not have matching underlying types. func getCurrentTool() -&gt; some Tool { switch currentTool { case &quot;pen&quot;: return Pen() case &quot;ruler&quot;: return Ruler() default: return Pencil() } }} some 关键字表示不透明的类型（opaque type）， 我们只需要知道他是一个符合 Tool 协议的东西， 但是具体是什么不知道，也不关心是什么，交给编译器去推断。 因为在三个 case 中返回的结果类型不一致，编译时无法推断 Tool 的类型， 而三个分支中使用的 Tool 是完全不同的东西，不能直接替换。 如果还有更多分支的话情况会更加复杂， 因此，若想统一类型，不妨创建一个类型橡皮擦来擦除原本的类型， 这时候每一个分支返回的类型都是“橡皮擦”的类型，也就没问题了。 类型擦除的原理以及实现 创建橡皮擦（以下称之为 Eraser），Eraser 要符合你的 Protocol 橡皮擦的名称一般是 Any + 协议名 12345struct AnyTool: Tool { func name() -&gt; some StringProtocol { }} 初始化中传入一个要被擦除类型的 Tool （下面称之为Type） 123init&lt;T: Tool&gt;(erasing tool: T) {} 创建中间变量来传递 Type 中的必要的方法和属性 12345internal let _name: Sinit&lt;T: Tool&gt;(erasing tool: T) { _name = (tool.name() as? S) ?? &quot;IDK.&quot;} 最后，用 name 来填补 Eraser 中需要的方法 123456789101112struct AnyTool: Tool { typealias S = String // This must be a type that conforms to StringProtocol. internal let _name: S init&lt;T: Tool&gt;(erasing tool: T) { _name = (tool.name() as? S) ?? &quot;IDK.&quot; } func name() -&gt; S { _name }} 在这里，我们将类型从 some StringProtocol 变成了 String 如果是 View，一般会把他替换成 AnyView 这里如果不能将 tool.name() 转换成 String 的话就返回 IDK. 这样一来，我们就可以将 Pen、Pencil、Ruler 都变成 AnyTool，解决了以上两个问题。 1234567891011121314151617class ToolController { var allTools: [AnyTool] = [] var currentTool = &quot;pen&quot; func getAllTools() { let tools = [AnyTool(erasing: Pen()), AnyTool(erasing: Pencil()), AnyTool(erasing: Ruler())] allTools = tools } func getCurrentTool() -&gt; some Tool { switch currentTool { case &quot;pen&quot;: return AnyTool(erasing: Pen()) case &quot;ruler&quot;: return AnyTool(erasing: Ruler()) default: return AnyTool(erasing: Pencil()) } }} 实现原理参考 Approaches to Type Erasure in Swift","link":"/type-erasure-in-swift/"},{"title":"WWDC 23 Swift Student Challenge","text":"有幸在高中就参与过 WWDC 20 的 SSC，可惜当时课余时间并不充裕导致作品的质量并不理想， 如今，再战 WWDC 23 SSC 😋 话又说回来，要不是官网宣布 WWDC 23 的时间并发布了 SSC 活动，我都差点忘记了😂 但是，我已不是三年前的我，这次的制作周期非常紧凑，也比较顺利，同时，相对来说也比较满意。 时光倒流（3月30日）早晨起来，瞄了一眼手表，我去…WWDC 23 定档了！！ 非常激动，也很开心（完全不记得有 SSC），点开官网，习惯性地翻了翻， 诶，SSC！！！还没准备怎么办？（我顿时愣住了，立马开始找灵感） 很快啊，有灵感了！！🤭 以上都是废话，你可以不看（好像说的有点晚了😂） 灵感SSC 是让学生爱好者们使用极具创新的方法来展现自己的 ideas， 使用 Playgrounds 提交作品，支持较新的 SDK，因此使用新的框架也能体现出对开发团队的支持（油管上听来的） 首先想到的就是 Swift Charts。 图表可以用在数据可视化，但是哪来那么多的数据呢？并且所有的核心要点要在三分钟之内被展现出来。 我突然想起了高数中的「泰勒展开式」，无限趋近的概念可以非常轻松的通过图表的可视化来展现。 又想起了上学期 C 语言课程中让我们实现 π 的计算。 因此，本次 SSC 的主题就定为了「使用 Swift Charts 来展现 π 的计算过程」，利用图表可视化展现出无限趋近的概念。 Playground 设计我希望向各位评委展现出我“高超”的 SwiftUI 本领，从布局到神奇移动，再到创新的交互，最后到动画设计与控制。 我不仅希望我的内容能够吸引评委，也希望我制作的动画能够让评委们感受到我对 SwiftUI 的热爱。 因此，我设计了6个分页。 欢迎页：展示 Playground 的主题、动态图标 目录页：展示神奇移动效果（有点为了神奇移动而神奇移动的感觉🤔） 简单思考页：展示创新点：刮刮卡 原理展示页：展示核心要点，Swift Charts、动画控制 回顾页：启发来源于之前获奖作品，为了和结束页动画配合。 结束页：展示动态图标和五彩纸屑效果（没错，就是 iMessage 中的五彩纸屑，用 Canvas 完美复刻了一个） 写在最后如果最终获奖了，Playground 中所有的源码我会开源在 GitHub：WWDC 23 SSC 5月10号之后链接还显示 404，就是很遗憾没获奖，再接再厉 🥹 五彩纸屑效果我在过年那会儿就已经写好并放在 GitHub 开源了，如果你有兴趣可以去研究下实现原理。","link":"/wwdc-23-swift-student-challenge/"},{"title":"在 Mac 上更安全地使用 EasyConnect","text":"起因还是偶然在 B 站刷到这么一个视频： 哟，原来是个流氓软件啊，草！！！！！！ 安装它，主要是因为学校内网要用 VPN 才能登陆， 起初安装完我就发现有后台权限的开关， 我也尝试关掉了，但是没法连接了（表现为一直在初始化） 为什么说他流氓后台持续活动打开“活动监视器”（Windows 上是 “任务管理器”）， 就能找到名为 EasyMonitor 和 ECAgent 的两个进程，关键是以 root 权限运行， 意味着，他想干嘛就干嘛，不需要我任何授权，我也浑然不知。 观察了一会儿，CPU 一直都有 0.3 - 0.5 的占用， 意味着，有少量代码在持续运行，在干嘛，不知道。 尝试关掉它？呵呵，太小看它了。关了又自动启动了。 安装了系统根证书打开 钥匙串访问 - 系统钥匙串 - 系统 - 证书，搜索 Sangfor， 就能看到一个 自己颁给自己 的一个证书，到 2117 年过期… 理论上这样可以劫持 HTTPS 活动。 引用 在 macOS 上安全使用 EasyConnect 的说法： 以 root 权限常驻进程，意味着这些进程可以读取和写入任何东西； 安装根证书，意味着可以直接进行中间人攻击。因此我们需要解决这些问题。 解决方法具体方法可以参考 在 macOS 上安全使用 EasyConnect 关闭自启动 和 后台驻留123sudo surm -r -f /Library/LaunchDaemons/com.sangfor.EasyMonitor.plistrm -r -f /Library/LaunchAgents/com.sangfor.ECAgentProxy.plist 以上代码适用于 Mac 重启电脑一定要重启‼️因为现在它还有后台驻留的权限‼️ 删除根证书在 钥匙串访问 - 系统钥匙串 - 系统 - 证书 下搜索 Sangfor，删除对应的所有证书。 到此，开机自启动 和 后台驻留 的问题解决了，但是 EasyConnect 也彻底用不了了， 可能会出现 “一直初始化中…” 的问题。 脚本配置上面那个参考链接里面给出了具体脚本，有打开和关闭两个， 我将他们统一了，点这里下载 这是一个没有扩展名的文件，用文本编辑器打开就能看到 bash 命令。 为脚本添加运行权限1chmod +x &lt;easyconnect 文件路径&gt; 图标变成一个黑色的框框，里面写着 exec 就对了。 导入我的脚本把 easyconnect 放到 /usr/local/bin 文件夹下。 这个目录可能需要在访达中按 Command + Shift + G 后输入。 一切就绪安全地启动 使用 EasyConnect 的时候，只需在终端输入这行命令： 1easyconnnect open 在使用过程中不要关闭终端窗口‼️ 虽然但是， 你可能会发现，EasyMonitor 和 ECAgent 仍然是以 root 权限运行的， 因此还需要手动关闭他们。 彻底地关闭 断开 VPN 后，除了退出 EasyConnect 本身，需要执行这行命令： 1easyconnect kill 这样一来，刚才启动的 EasyMonitor 和 ECAgent 就会被关闭， 由于没有后台驻留的权限，也就不会重新启动了。 整个方案是按需使用的策略，因为 EasyMonitor 和 ECAgent 是初始化时必要的进程。 快捷指令如果你觉得整个过程比较复杂， 也可以使用我制作的快捷指令：Toggle Easy Connect 来让这一切变得自动化。 快捷指令会自动检测 EasyMonitor 的运行情况来作为 EasyConnect 是否正在运行的标志， 进而自动选择合适的命令。 疑难解答 登陆之后闪退 重启电脑即可。这是由于某些组建启动了多次后产生了冲突。","link":"/use-easy-connect-safely-on-your-mac/"},{"title":"SwiftUI 新功能","text":"本文为 What’s new in SwiftUI 的学习笔记 SwiftUI 的更多应用场景适用于 visionOS 的 Scenes WindowGroup：SwiftUI 可以直接应用于 visionOS 中，不需要任何设置，以平面的方式显示。 要想增加「深度」上的支持，可以使用 .windowStyle(.volumetric)。 Model3D：载入静态模型 RealityView：载入动态模型，包括光线追踪、交互等 ImmersiveSpace：构建完全「沉浸式」的体验。 watchOS 10watchOS 10 经过重新设计。 NavigationSplitView、TabView、NavigationStack 在 watchOS 中也得到的重大更新，并有了新的动画效果 部分 API 得到改进： .containerBackground(for: .navigation) { ... }：设置容器背景，在不同容器中切换时能够顺滑切换 ToolbarItem 新增 topBarLeading 和 topBarTrailing（均包含跨平台支持） 支持 DatePicker 和 List selection Widgets所有平台的 Widgets 均由 SwiftUI 构建。 🎉 Widget 支持「交互和动画」 Widget 按钮点击后触发的是 Bundle 里的 App Intents 相关代码 用 .animation 和 .transition 为元素增加动画 Previews 基于 SwiftUI 5.9，你可以用宏来构建 Preview macOS app 支持 Live Preview 123#Preview(&quot;Preview Name&quot;) { ...} 预览 Widget 动画： 12345678#Preview(as: .systemSmall) { CaffeineTrackerWidget()} timeline: { CaffeineLogEntry.log1 CaffeineLogEntry.log2 CaffeineLogEntry.log3 CaffeineLogEntry.log4} 更多更新： MapKit for SwiftUI：更全面地控制、自定义 Swift Charts：支持滚动、选择、饼/环状图 StoreKit for SwiftUI：更简单地构建内购页面 … 简化的数据流@Observable 12345678@Observableclass Dog: Identifiable { var id = UUID() var name = &quot;&quot; var age = 1 var breed = DogBreed.mutt var owner: Person? = nil} 1234struct DogCard: View { var dog: Dog // 之前的写法：@ObservedObject var dog: Dog ...} SwiftUI 中的数据流被简化成 @State 和 @Environment @State 处理可更改的变量 @Environment 融合了原先的 @EnvironmentObject 12345678910111213141516171819202122232425262728293031import SwiftUI@mainstruct WhatsNew2023: App { @State private var currentUser: User? var body: some Scene { WindowGroup { ProfileView() .environment(currentUser) } } struct ProfileView: View { @Environment(User.self) private var currentUser: User? var body: some View { if let currentUser { UserDetails(user: currentUser) } else { Button(&quot;Log In&quot;) { } } } } @Observable class User: Identifiable { var id = UUID() var name = &quot;&quot; }} SwiftData隆重介绍，SwiftData。 SwiftData 提供了 Swift 式的 Core Data 实现，支持 Swift 5.9 的宏。 只需要把 @Observable 改为 @Model 就可以了，不用担心，@Observable 的能力也会完全保留。 在 SwiftUI 中，使用 @Query 来查询数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import Foundationimport SwiftUIimport SwiftDatastruct RecentDogsView: View { @Query(sort: \\.dateSpotted) private var dogs: [Dog] var body: some View { ScrollView(.vertical) { LazyVStack { ForEach(dogs) { dog in DogCard(dog: dog) } } } } struct DogCard: View { var dog: Dog var body: some View { DogImage(dog: dog) .overlay(alignment: .bottom) { HStack { Text(dog.name) Spacer() Image(systemName: &quot;heart&quot;) .symbolVariant(dog.isFavorite ? .fill : .none) } .font(.headline) .padding(.horizontal, 22) .padding(.vertical, 12) .background(.thinMaterial) } .clipShape(.rect(cornerRadius: 16)) } } struct DogImage: View { var dog: Dog var body: some View { Rectangle() .fill(Color.green) .frame(width: 400, height: 400) } } @Model class Dog: Identifiable { var name = &quot;&quot; var isFavorite = false var dateSpotted = Date.now }}#Preview { RecentDogsView()} Document-Based App 增加了一个全新的 API 用以快速构建 model container： 1234567891011121314151617181920212223242526272829import SwiftUIimport SwiftDataimport UniformTypeIdentifiers@mainprivate struct WhatsNew2023: App { var body: some Scene { DocumentGroup(editing: DogTag.self, contentType: .dogTag) { ContentView() } } struct ContentView: View { var body: some View { Color.clear } } @Model class DogTag { var text = &quot;&quot; }}extension UTType { static var dogTag: UTType { UTType(exportedAs: &quot;com.apple.SwiftUI.dogTag&quot;) }} 文档编辑器现自动支持分享和重命名 文档编辑器的 toolbar 中默认加入 Undo &amp; Redo 新的 Inspector View：用于修改选中内容的属性，并能自适应不同尺寸的设备 .fileMover，.fileImporter，.fileExporter 支持自定义 Label .confirmationDialog 支持「不再询问」、「严重等级」 HelpLink：「帮助」按钮 Table 持久化自定义列 大纲视图 程序化控制 Section 展开与否 backgroundProminence 使得 UI 更加灵活、易读 更多表格自定义选项，例如：可隐藏表头，可关闭隔行背景等 Performance对于大数据集，SwiftUI 的性能有很大提升。 具体的这里没说，到时候关注下 Demystify SwiftUI performance 精美的动画 关键帧动画可以分别对多个属性添加多个关键帧，并指定每一段的动画曲线 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import SwiftUIstruct KeyframeAnimator_Snippet: View { var body: some View { Logo(color: .blue) Text(&quot;Tap the shape&quot;) }}struct Logo: View { var color: Color @State private var runPlan = 0 var body: some View { VStack(spacing: 100) { KeyframeAnimator( initialValue: AnimationValues(), trigger: runPlan ) { values in LogoField(color: color) .scaleEffect(values.scale) .rotationEffect(values.rotation, anchor: .bottom) .offset(y: values.verticalTranslation) .frame(width: 240, height: 240) } keyframes: { _ in KeyframeTrack(\\.verticalTranslation) { SpringKeyframe(30, duration: 0.25, spring: .smooth) CubicKeyframe(-120, duration: 0.3) CubicKeyframe(-120, duration: 0.5) CubicKeyframe(10, duration: 0.3) SpringKeyframe(0, spring: .bouncy) } KeyframeTrack(\\.scale) { SpringKeyframe(0.98, duration: 0.25, spring: .smooth) SpringKeyframe(1.2, duration: 0.5, spring: .smooth) SpringKeyframe(1.0, spring: .bouncy) } KeyframeTrack(\\.rotation) { LinearKeyframe(Angle(degrees:0), duration: 0.45) CubicKeyframe(Angle(degrees: 0), duration: 0.1) CubicKeyframe(Angle(degrees: -15), duration: 0.1) CubicKeyframe(Angle(degrees: 15), duration: 0.1) CubicKeyframe(Angle(degrees: -15), duration: 0.1) SpringKeyframe(Angle(degrees: 0), spring: .bouncy) } } .onTapGesture { runPlan += 1 } } } struct AnimationValues { var scale = 1.0 var verticalTranslation = 0.0 var rotation = Angle(degrees: 0.0) } struct LogoField: View { var color: Color var body: some View { ZStack(alignment: .bottom) { RoundedRectangle(cornerRadius: 48) .fill(.shadow(.drop(radius: 5))) .fill(color.gradient) } } }}#Preview { KeyframeAnimator_Snippet()} 多阶段动画对于可拆分为多个阶段的动画，相较于关键帧动画，多阶段动画显得更加简单，在这里可以设置每个阶段对应的动画方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import SwiftUIstruct PhaseAnimator_Snippet: View { @State private var sightingCount = 0 var body: some View { VStack { Spacer() HappyDog() .phaseAnimator( SightingPhases.allCases, trigger: sightingCount ) { content, phase in content .rotationEffect(phase.rotation) .scaleEffect(phase.scale) } animation: { phase in switch phase { case .shrink: .snappy(duration: 0.1) case .spin: .bouncy case .grow: .spring( duration: 0.2, bounce: 0.1, blendDuration: 0.1) case .reset: .linear(duration: 0.0) } } .sensoryFeedback(.increase, trigger: sightingCount) Spacer() Button(&quot;There’s One!&quot;, action: recordSighting) .zIndex(-1.0) } } func recordSighting() { sightingCount += 1 } enum SightingPhases: CaseIterable { case reset case shrink case spin case grow var rotation: Angle { switch self { case .spin, .grow: Angle(degrees: 360) default: Angle(degrees: 0) } } var scale: Double { switch self { case .reset: 1.0 case .shrink: 0.75 case .spin: 0.85 case .grow: 1.0 } } }}struct HappyDog: View { var body: some View { ZStack(alignment: .center) { Rectangle() .fill(.blue.gradient) Text(&quot;🐶&quot;) .font(.system(size: 58)) } .clipShape(.rect(cornerRadius: 12)) .frame(width: 96, height: 96) }}#Preview { PhaseAnimator_Snippet()} 触觉反馈.sensoryFeedback(.increase, trigger: sightingCount) 根据不同平台会有不同的效果，你看需要参考 HIG 该 modifier 是由数据驱动的，当数据变化时才会触发，我之前也做过类似的库：SwiftUI-Haptics 视觉效果基于位置的动画效果，之前需要用到 GeometryReader，但由于其会占据尽可能大的空间，可能会导致很多问题。 之前的解决方案可能是把 GeometryReader 放在 .overlay 中保持和元素大小位置一致。 在 SwiftUI 5 中，可以直接使用 .visualEffect 即可。 123456789101112131415161718import SwiftUIstruct DogCircle: View { var dog: Dog var focalPoint: CGPoint var body: some View { ZStack { DogImage(dog: dog) .visualEffect { content, geometry in content .scaleEffect(contentScale(in: geometry)) .saturation(contentSaturation(in: geometry)) .opacity(contentOpacity(in: geometry)) } } }} 话说，这个思路貌似就是之前的 .overlay + GeometryReader，这个 API 应该是可以做向后兼容的，我简单写了一个作为参考。 123456789101112public extension View { @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *) @backDeployed(before: macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0) @ViewBuilder func visualEffect&lt;VisualEffect&gt;(@ViewBuilder _ effect: @escaping (Self, GeometryProxy) -&gt; VisualEffect) -&gt; some View where VisualEffect : View { self.hidden().overlay { GeometryReader { currentProxy in effect(self, currentProxy) } } }} 文本格式化增强在之前的版本中，可以在 Text 中嵌套 Text 或 Image，类似 Text(&quot;\\(Text(&quot;Hello&quot;)) SwiftUI&quot;) 在 SwiftUI 5.0 中，可以使用 Shader 来格式化文本，其中，Shader 使用 Metal API 构建 123456789101112131415161718192021222324import SwiftUIstruct ShaderUse_Snippet: View { var body: some View { Text( &quot;&quot;&quot; \\( Text(&quot;Furdinand&quot;) .foregroundStyle(stripes) .fontWidth(.expanded) ) \\ is a good dog! &quot;&quot;&quot; ) } var stripes: Shader { ShaderLibrary.angledFill( .float(stripeSpacing), .float(stripeAngle), .color(.blue) ) }} 其他 滑块组件增加左右图标到底回弹效果（由新版本 SF Symbols 支持） SF Symbol 新增动画效果，例如：回弹、缩放，脉冲等 .textScale 简化了 Small Caps 的实现方式，对于没有 Small Caps 排版的语言来说，也能正常显示为小文本 对于高文本（例如泰语中的一些字符），使用 .typesettingLanguage 来自动优化行间距 Curt: I’ve only scratched the surface here. There’s even more to discover, from animation completion handlers to building entirely custom animations. I hope you enjoy these APIs as much as I do. 交互增强 ScrollView .scrollTransition：构建滚动时的元素动画 .containerRelativeFrame：基于容器尺寸给出元素的相对大小12YourView() .containerRelativeFrame(.horizontal, count: 5, span: 2, spacing: 8) 指定元素相对容器的大小，将容器在横向分为 5 块，每一个元素占据 2 块的位置，元素与元素间间距为 8px .scrollTargetLayout() 将容器中的元素作为一个个目标，允许一个个滚动。 .scrollTargetBehavior 提供了对高级滚动行为的控制，包括 .paging 和 .viewAligned .scrollPosition 可以实时获取到可见区域内最上面的的元素的 ID Image .allowsDynamicRange(.high)：HDR 渲染图片 更好的辅助功能支持，例如：缩放等 Color 以枚举的形式使用自定义颜色，不用再担心 typo-errors 了 1Color(.deeeepPurple) 样式 ControlGroup 新增 CompactMenu 样式 Picker 新增 Palette 样式 .paletteSelectionEffect 简化了 Picker 中的 “选中/未选中” 状态显示 新增 ButtonBorderShape.circle 新增 .springLoadingBehavior，允许在 Drag &amp; Drop 时触发操作 tvOS 支持 BorderlessButtonStyle 新增 .onKeyPress 用以响应键盘输入 / 快捷键 写在后面今年 SwiftUI 的改进还是很大的，总结一下： 新的适用平台 与现有框架的更好融合 新的数据流结构，@Observable，@Model，SwiftData 可控、个性化动画 大量全新 modifiers ScrollView 增强 … 这篇还属于是一些皮毛，后面还有很多更加深入的 Session 来讨论各个板块的内容。 我们下期再会。🤭","link":"/wwdc-23-whats-new-in-swiftui/"}],"tags":[{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"watchOS","slug":"watchOS","link":"/tags/watchOS/"},{"name":"Apple Watch","slug":"Apple-Watch","link":"/tags/Apple-Watch/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"写代码","slug":"写代码","link":"/tags/%E5%86%99%E4%BB%A3%E7%A0%81/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"泛型","slug":"泛型","link":"/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"hack","slug":"hack","link":"/tags/hack/"},{"name":"IP定位","slug":"IP定位","link":"/tags/IP%E5%AE%9A%E4%BD%8D/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Leancloud","slug":"Leancloud","link":"/tags/Leancloud/"},{"name":"CDN","slug":"CDN","link":"/tags/CDN/"},{"name":"Apple Store","slug":"Apple-Store","link":"/tags/Apple-Store/"},{"name":"Macbook Pro","slug":"Macbook-Pro","link":"/tags/Macbook-Pro/"},{"name":"Magic Keyboard","slug":"Magic-Keyboard","link":"/tags/Magic-Keyboard/"},{"name":"WWDC 23","slug":"WWDC-23","link":"/tags/WWDC-23/"},{"name":"SwiftUI","slug":"SwiftUI","link":"/tags/SwiftUI/"},{"name":"Swift Data","slug":"Swift-Data","link":"/tags/Swift-Data/"},{"name":"代码调优","slug":"代码调优","link":"/tags/%E4%BB%A3%E7%A0%81%E8%B0%83%E4%BC%98/"},{"name":"Apple Script","slug":"Apple-Script","link":"/tags/Apple-Script/"},{"name":"Sandbox","slug":"Sandbox","link":"/tags/Sandbox/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"},{"name":"Swift Charts","slug":"Swift-Charts","link":"/tags/Swift-Charts/"},{"name":"WWDC 22","slug":"WWDC-22","link":"/tags/WWDC-22/"},{"name":"Concurrency","slug":"Concurrency","link":"/tags/Concurrency/"},{"name":"swiftui","slug":"swiftui","link":"/tags/swiftui/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"MarkdownView","slug":"MarkdownView","link":"/tags/MarkdownView/"},{"name":"类型擦除","slug":"类型擦除","link":"/tags/%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4/"},{"name":"Swift Student Challenge","slug":"Swift-Student-Challenge","link":"/tags/Swift-Student-Challenge/"}],"categories":[{"name":"吐个槽","slug":"吐个槽","link":"/categories/%E5%90%90%E4%B8%AA%E6%A7%BD/"},{"name":"学个习","slug":"学个习","link":"/categories/%E5%AD%A6%E4%B8%AA%E4%B9%A0/"},{"name":"瞎折腾","slug":"瞎折腾","link":"/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"},{"name":"撸代码","slug":"撸代码","link":"/categories/%E6%92%B8%E4%BB%A3%E7%A0%81/"},{"name":"新玩具","slug":"新玩具","link":"/categories/%E6%96%B0%E7%8E%A9%E5%85%B7/"}],"pages":[{"title":"关于我","text":"全民制作人们大家好，我是练习时长两年半的个人练习生 —— ikun 喜欢唱、跳、rap、篮球（music~) 🐔你太美～ 哈哈，我是真 iKun，别被气孕哦～ 言归正传。 我是一名大学生，就读于SUEP。 很高兴你能来访问我的博客！！ 在这里，我会分享自己的日常、瞎折腾的经历等等… 我的开源库 MarkdownView 基于 apple/swift-markdown 做的 SwiftUI 组件，尽可能地以原生的方式来渲染 Markdown 内容。 SwiftUI-Haptics SwiftUI-Haptics 是一个 SwiftUI 的库，用于实现视图内的触觉反馈，提供了多个 View Modifiers，包括关联状态属性的触觉反馈和手动触觉反馈两种模式。","link":"/about.html"},{"title":"","text":"404 - 啊哦，出错了 你所访问的资源不存在，该资源可能被修改了路径或被删除 网站仍在建设中！ 有一篇文章的链接有变动： 就爱在网上BB？IP直接拿捏你 你可以尝试下列方法： 检查链接 已知的问题 给我反馈 对于手动输入链接的读者：请先自行检查链接是否正确，有无拼写错误等… 对于点击按钮跳转的读者：请进入下一板块。 相册：/photos 有一篇文章的链接有变动： 就爱在网上BB？IP直接拿捏你 先检查前几项是否能够解决问题，别直接就反馈哦！😂 如果都不行请复制该页面的链接 给我反馈。 请一定要按照模版写，不然就作废。 正在持续改进中：2022.10.11 博客内的图片改为直链，之前的貌似还是不行，哎.. 2022.10.5 增加本页面的「最近更新」板块 修改了字体、样式、脚本的 CDN，就是说 网页加载变快了 博客内的图片改用 jsDelivr 镜像站！（GitHub issue里的大佬给的！） 2022.10.4 修复 cdn 导致的国内资源加载失败问题（#相关文章） 新增本页面","link":"/404.html"},{"title":"留言板","text":"来都来了，说两句呗😁","link":"/messages.html"},{"title":"与“我”对话","text":"","link":"/talk-with-me.html"}]}